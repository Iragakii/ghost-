<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Ghost & Boss Duck</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            font-family: monospace;
            user-select: none;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            cursor: grab;
        }
        
        #canvas-container.grab-cursor {
            cursor: grab;
        }
        
        #canvas-container.grabbing-cursor {
            cursor: grabbing;
        }

        #hud {
            display: flex;
            position: fixed;
            top: 16px;
            left: 8%;
            transform: translateX(-50%);
            border-radius: 12px;
            color: #A8DF65;
            ;
            font-weight: bold;
            padding: 7px 18px;
            font-size: 30px;
            pointer-events: none;
            backdrop-filter: blur(6px);
            text-align: center;
            line-height: 1.8;
        }

        #c {
            font-size: 16px;
            color: #A8DF65;
            margin-left: 5px;
        }

        #jp {
            position: fixed;
            top: 70px;
            left: 8.4%;
            transform: translateX(-50%);
            border: none;
            border-radius: 8px;
            color: #EDF492;
            font-size: 12px;
            z-index: 10;
        }

        #ce {
            position: fixed;
            top: 100px;
            left: 3%;
            border: none;
            border-radius: 8px;
            color: #EDF492;
            font-size: 12px;
            text-align: right;
            z-index: 10;
            text-transform: uppercase;
        }

        #ex {
            position: fixed;
            top: 112px;
            left: 3%;
            border: none;
            border-radius: 8px;
            color: #EDF492;
            font-size: 12px;
            text-align: left;
            z-index: 10;
            text-transform: uppercase;
        }

        #ceex {
            display: block;
        }

        #ra {
            position: fixed;
            top: 130px;
            left: 3%;
            border: none;
            border-radius: 8px;
            color: #EDF492;
            font-size: 12px;
            text-align: right;
            z-index: 10;
            text-transform: uppercase;
        }

        #up {
            position: fixed;
            top: 200px;
            left: 6%;
            font-size: 15px;
            color: #EDF492;
            z-index: 10;
            background-color: #A8DF65;
            border-radius: 23%;
            width: 24px;
            height: 24px;
            line-height: 24px;
            text-align: center;
        }

        #arb {
            position: fixed;
            top: 230px;
            left: 3.3%;
            font-size: 20px;
            display: flex;
            gap: 15px;
        }

        #left,
        #down,
        #right {
            color: #EDF492;
            background-color: #A8DF65;
            border-radius: 23%;
            width: 24px;
            height: 24px;
            line-height: 24px;
            text-align: center;
            font-size: 15px;
            margin: 0;
        }

        #con {
            color: #EDF492;
            font-size: 11px;
            text-align: center;
            z-index: 10;
            text-transform: uppercase;
            font-weight: bold;
            margin-top: 11px;
        }

        #brb {
            position: fixed;
            top: 300px;
            left: 4.3%;
            font-size: 20px;
            display: flex;
            gap: 15px;
        }

        #sp {
            font-size: 20px;
            color: #EDF492;
            background-color: #A8DF65;
            border-radius: 8px;
            width: 60px;
            height: 24px;
            line-height: 24px;
            text-align: center;
            font-size: 11px;
            padding-right: 5px;
            padding-left: 5px;
        }

        #jump {
            color: #EDF492;
            font-size: 11px;
            text-align: center;
            z-index: 10;
            text-transform: uppercase;
            font-weight: bold;
            margin-top: 11px;
            margin-left: 20px;
        }

        #bw {
            position: fixed;
            bottom: 15px;
            right: 16px;
            padding: 10px 14px;
            background: #A8DF65;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            cursor: pointer;
            z-index: 10;

        }

        .char-notification {
            position: fixed;
            background: #A8DF65;
            color: #000;

            padding: 8px 16px;
            border-radius: 8px;
            font-size: 20px;
            font-weight: bold;
            pointer-events: none;
            z-index: 100;
            display: none;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }

        .char-chat {
            position: fixed;
            background: #EDF492;
            color: #000;
            padding: 10px 18px;
            border-radius: 12px;
            font-size: 16px;
            font-weight: bold;
            pointer-events: none;
            z-index: 100;
            display: none;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            max-width: 250px;
            text-align: center;
        }

        .chars-chat {
            position: fixed;
            background: #262626;
            color: #ACBFA4;
            padding: 5px 10px;
            border-radius: 12px;
            font-size: 16px;
            font-weight: bold;
            pointer-events: none;
            z-index: 100;
            display: none;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            max-width: 250px;
            text-align: center;
        }

        .chars-notification {
            position: fixed;
            background: #262626;
            color: #ACBFA4;
            padding: 8px 16px;
            border-radius: 8px;
            font-size: 20px;
            font-weight: bold;
            pointer-events: none;
            z-index: 100;
            display: none;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }
    </style>
    <script
        type="importmap">{"imports":{"three":"https://cdn.jsdelivr.net/npm/three@0.183.0/build/three.module.js","three/addons/":"https://cdn.jsdelivr.net/npm/three@0.183.0/examples/jsm/"}}</script>
</head>

<body>
    <audio id="bgMusic" autoplay loop>
        <source src="hehe.mp3" type="audio/mpeg">
    </audio>
    <div id="canvas-container"></div>
    <div>
        <div id="hud">J <div id="c">©</div>
            <div>GROUP</div>
        </div>
        <div id="jp">
            富士山から風が吹いてきます</div>

        <div id="ce"> creative development </div>

        <div id="ex">& experience designer</div>
        <div id="ra">RAISED ON '90s CLASSIC</div>
        <div id="up">▲</div>
        <div id="arb">
            <div id="left">◀</div>
            <div id="down">▼</div>
            <div id="right">▶</div>
            <div id="con">CONTROL</div>
        </div>
        <div id="brb">
            <div id="sp">SPACE</div>
            <div id="jump">JUMP</div>

        </div>
    </div>
    <button id="bw">|||</button>
    <!-- Character Interaction Notifications -->
    <div id="char1-notif" class="char-notification">F</div>
    <div id="char1-chat" class="char-chat">Hello, U should press J K L</div>
    <div id="char2-notif" class="char-notification">F</div>
    <div id="char2-chat" class="char-chat">Hello , U should press Enter Duck </div>
    <div id="char3-notif" class="char-notification">F</div>
    <div id="char3-chat" class="char-chat">Hello</div>
    <div id="f-notif" class="char-notification">F</div>
    <div id="f-chat" class="char-chat">I dont want to be at that party</div>
    <div id="angle-notif" class="chars-notification">F</div>
    <div id="angle-chat" class="chars-chat">Hello</div>
    <div id="angle-q-notif" class="chars-notification">Q</div>
    <div id="ve-notif" class="char-notification">F</div>
    <div id="ve-chat" class="char-chat">I was try my best </div>
    <div id="pp-notif" class="char-notification">F</div>
    <div id="pp-chat" class="char-chat">I want can have Q to sing like her</div>
    <div id="lm-notif" class="chars-notification">F</div>
    <div id="lm-chat" class="chars-chat">Hello</div>
    <div id="fat-notif" class="chars-notification">F</div>
    <div id="fat-chat" class="chars-chat">Hello</div>
    <div id="newchar-notif" class="chars-notification">F</div>
    <div id="newchar-chat" class="chars-chat">You should Do my prompt better .........</div>
    <div id="angle-song-embed-container"
        style="display: none; position: fixed; top: 10px; right: 20px; z-index: 1000;  border-radius: 12px; box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3); padding: 12px; width: 300px; max-height: 150px; overflow: hidden; pointer-events: auto;">
        <button id="angle-song-close"
            style="position: absolute; top: 8px; right: 8px; background: #BBCB2E; color: white; border: none; border-radius: 50%; width: 24px; height: 24px; cursor: pointer; font-size: 16px; line-height: 1; display: flex; align-items: center; justify-content: center; z-index: 1001; transition: background 0.2s; pointer-events: auto;"
            onmouseover="this.style.background='#cc0000'" onmouseout="this.style.background='#ff4444'">×</button>
        <iframe id="angle-song-embed" style="width: 100%; height: 100%; border: none; border-radius: 8px; pointer-events: auto;"></iframe>
    </div>
    
    <!-- Custom URL Input Modal -->
    <div id="url-input-modal" style="display: none; position: fixed; top: 60px; right: 100px; width: 200px; height: 80px;  z-index: 2000; align-items: center;">
        <div style=" border-radius: 12px; padding: 24px; min-width: 200px; max-width: 200px; box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);">
            <div style="color: #90EE90; font-size: 14px; margin-bottom: 16px;">Give me song URL I will sings for u</div>
            <input type="text" id="url-input-field" placeholder="Enter URL here..." style="width: 100%; padding: 10px; border: 1px solid #90EE90; border-radius: 8px; background: rgba(0, 0, 0, 0.3); color: #90EE90; font-size: 14px; margin-bottom: 16px; outline: none; box-sizing: border-box;" autofocus>
            <div style="display: flex; justify-content: flex-end; gap: 12px;">
                <button id="url-input-ok" style="background: #90EE90; color: #1a3a1a; border: none; border-radius: 20px; padding: 8px 20px; cursor: pointer; font-size: 14px; font-weight: 500; transition: background 0.2s;" onmouseover="this.style.background='#7acc7a'" onmouseout="this.style.background='#90EE90'">OK</button>
                <button id="url-input-cancel" style="background: #1a3a1a; color: #90EE90; border-radius: 20px; padding: 5px 15px; cursor: pointer; font-size: 14px; font-weight: 500; transition: background 0.2s;" onmouseover="this.style.background='#2d4a2d'" onmouseout="this.style.background='#1a3a1a'">Cancel</button>
            </div>
        </div>
    </div>
    
    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        const defultScale = new THREE.Vector3(1, 1, 1);
        const targetScale = new THREE.Vector3(1, 1, 1);

        const bgMusic = document.getElementById('bgMusic');
        bgMusic.volume = 0.3;
        // Prevent bg music from playing while ang.mp3 or custom song is playing
        bgMusic.addEventListener('play', (e) => {
            if (isAngleSoundPlaying || isAngleSongPlaying) {
                bgMusic.pause();
                e.preventDefault();
            }
        });
        bgMusic.play().catch(e => console.log('Autoplay blocked, will play on interaction'));

        // Initialize AudioContext once at startup
        let audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        // Don't resume here - let it be suspended until first sound plays

        const bwButton = document.getElementById('bw');
        let isMusicPlaying = true;
        bwButton.addEventListener('click', () => {
            if (isMusicPlaying) {
                bgMusic.pause();
                bwButton.textContent = '▶';
                isMusicPlaying = false;
            } else {
                bgMusic.play();
                bwButton.textContent = '||';
                isMusicPlaying = true;
            }
            bwButton.blur();
        });

        function initAudio() {
            // Already initialized at startup - this now does nothing
        }
        function playJumpSound() {
            if (!audioCtx) return;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.type = 'sine';
            osc.frequency.setValueAtTime(400, audioCtx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(
                800,
                audioCtx.currentTime + 0.15
            );
            gain.gain.setValueAtTime(0, audioCtx.currentTime);
            gain.gain.linearRampToValueAtTime(0.05, audioCtx.currentTime + 0.02);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.15);
            osc.start(audioCtx.currentTime);
            osc.stop(audioCtx.currentTime + 0.15);
        }
        function playDuckWalkSound() {
            if (!audioCtx) return;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.type = 'triangle';
            osc.frequency.setValueAtTime(500, audioCtx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(
                800,
                audioCtx.currentTime + 0.08
            );
            gain.gain.setValueAtTime(0, audioCtx.currentTime);
            gain.gain.linearRampToValueAtTime(0.05, audioCtx.currentTime + 0.02);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.15);
            osc.start(audioCtx.currentTime);
            osc.stop(audioCtx.currentTime + 0.15);
        }
        // ── Scene ─────────────────────────────────────────────────────────────────────
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0xffb6c1, 0.013);

        const camera = new THREE.PerspectiveCamera(60, innerWidth / innerHeight, 0.1, 2000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(innerWidth, innerHeight);
        renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.0;
        container.appendChild(renderer.domElement);

        // ── Sky ───────────────────────────────────────────────────────────────────────
        scene.add(new THREE.Mesh(
            new THREE.SphereGeometry(500, 32, 15),
            new THREE.ShaderMaterial({
                uniforms: { topColor: { value: new THREE.Color(0xff99cc) }, bottomColor: { value: new THREE.Color(0xffe6f2) }, offset: { value: 33 }, exponent: { value: 0.6 } },
                vertexShader: `varying vec3 vW; void main(){ vW=(modelMatrix*vec4(position,1.)).xyz; gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.); }`,
                fragmentShader: `uniform vec3 topColor,bottomColor; uniform float offset,exponent; varying vec3 vW;
        void main(){ float h=normalize(vW+offset).y; gl_FragColor=vec4(mix(bottomColor,topColor,max(pow(max(h,0.),exponent),0.)),1.); }`,
                side: THREE.BackSide
            })
        ));

        // ── Terrain ───────────────────────────────────────────────────────────────────
        const floorGeo = new THREE.PlaneGeometry(600, 600, 200, 200);
        const floor = new THREE.Mesh(floorGeo, new THREE.MeshStandardMaterial({ color: 0xff66b2, roughness: 0.7, metalness: 0.1, flatShading: true }));
        floor.rotation.x = -Math.PI / 2;
        floor.receiveShadow = true;
        scene.add(floor);
        function getTerrainY(x, z, t) { return Math.sin(x * 0.2 + t) * Math.cos(z * 0.2 + t) * 1.5; }

        // ── Particles ─────────────────────────────────────────────────────────────────
        const pCount = 10000, pGeo = new THREE.BufferGeometry(), pPos = new Float32Array(pCount * 3), pVel = [];
        for (let i = 0; i < pCount; i++) {
            pPos[i * 3] = (Math.random() - .5) * 600; pPos[i * 3 + 1] = Math.random() * 100; pPos[i * 3 + 2] = (Math.random() - .5) * 600;
            pVel.push({ x: (Math.random() - .5) * .02, y: (Math.random() - .5) * .02, z: (Math.random() - .5) * .02 });
        }
        pGeo.setAttribute('position', new THREE.BufferAttribute(pPos, 3));
        const particles = new THREE.Points(pGeo, new THREE.PointsMaterial({ color: 0xffffff, size: 0.4, transparent: true, opacity: 0.6, blending: THREE.AdditiveBlending }));
        scene.add(particles);
        // ── Wind Particles (Flower design) ────────────────────────────────────────
        const flowerParticleCount = 150;
        const flowerColors = [0xff1493, 0xff69b4, 0xffb6c1, 0xffc0cb, 0xff00ff, 0xee82ee, 0xda70d6, 0xba55d3, 0x9370db, 0xff6347, 0xffa500, 0xffd700];

        // Create flower petal geometry
        function createFlowerGeometry() {
            const petals = 5;
            const points = [];

            // Create petal shape
            for (let p = 0; p < petals; p++) {
                const angle = (p / petals) * Math.PI * 2;
                const x = Math.cos(angle) * 0.3;
                const z = Math.sin(angle) * 0.3;
                const y = 0;

                // Petal curve
                points.push(new THREE.Vector3(x * 0.5, y - 0.2, z * 0.5));
                points.push(new THREE.Vector3(x * 0.8, y, z * 0.8));
                points.push(new THREE.Vector3(x * 0.5, y + 0.2, z * 0.5));

                // Center
                points.push(new THREE.Vector3(0, y - 0.1, 0));
            }

            return points;
        }

        const flowerGeo = new THREE.BufferGeometry();
        const flowerPetalPoints = createFlowerGeometry();
        let flowerInstanceData = [];

        for (let i = 0; i < flowerParticleCount; i++) {
            flowerInstanceData.push({
                position: new THREE.Vector3(0, 0, 0),
                velocity: new THREE.Vector3(0, 0, 0),
                life: 2.0,
                maxLife: 1.0,
                color: flowerColors[Math.floor(Math.random() * flowerColors.length)],
                rotation: Math.random() * Math.PI * 2
            });
        }

        // Create flower particles using individual meshes in a group
        const flowerGroup = new THREE.Group();
        scene.add(flowerGroup);

        const flowerMeshes = [];
        for (let i = 0; i < flowerParticleCount; i++) {
            const flowerGeoInstance = new THREE.IcosahedronGeometry(0.15, 2);
            const colorHex = flowerColors[Math.floor(Math.random() * flowerColors.length)];
            const flowerMat = new THREE.MeshStandardMaterial({
                color: colorHex,
                transparent: true,
                opacity: 0.8,
                emissive: colorHex,
                emissiveIntensity: 0.5,
                roughness: 0.4
            });
            const flowerMesh = new THREE.Mesh(flowerGeoInstance, flowerMat);
            flowerMesh.visible = false;
            flowerGroup.add(flowerMesh);
            flowerMeshes.push({
                mesh: flowerMesh,
                life: 2.0,
                maxLife: 1.0,
                velocity: new THREE.Vector3(0, 0, 0),
                colorIntensity: 1.0
            });
        }

        let flowerParticleIndex = 0;
        function spawnFlowerParticle(pos, vel, life = 1.0) {
            const idx = flowerParticleIndex % flowerParticleCount;
            const flower = flowerMeshes[idx];

            flower.mesh.position.copy(pos);
            flower.mesh.visible = true;
            flower.velocity.copy(vel);
            flower.life = 0;
            flower.maxLife = life;
            flower.mesh.scale.setScalar(1);

            flowerParticleIndex++;
        }

        // ── Wind Stream Particles (Straight lines) ────────────────────────────────────
        const windStreamCount = 300;
        const windStreamGeo = new THREE.BufferGeometry();
        const windStreamPos = new Float32Array(windStreamCount * 6); // 2 points per line segment
        const windStreamVel = [];
        const windStreamLife = [];
        const windStreamMaxLife = [];

        for (let i = 0; i < windStreamCount; i++) {
            // Start point
            windStreamPos[i * 6] = 0;
            windStreamPos[i * 6 + 1] = 0;
            windStreamPos[i * 6 + 2] = 0;
            // End point
            windStreamPos[i * 6 + 3] = 0;
            windStreamPos[i * 6 + 4] = 0;
            windStreamPos[i * 6 + 5] = 0;

            windStreamVel.push({ x: 0, y: 0, z: 0, dirX: 0, dirY: 0, dirZ: 0, trailLen: 1 });
            windStreamLife.push(2.0); // Start dead
            windStreamMaxLife.push(1);
        }
        windStreamGeo.setAttribute('position', new THREE.BufferAttribute(windStreamPos, 3));

        const windStreamParticles = new THREE.LineSegments(windStreamGeo, new THREE.LineBasicMaterial({
            color: new THREE.Color(0xA82323),
            transparent: true,
            opacity: 1.0,
            linewidth: 4,
            blending: THREE.NormalBlending,
            fog: false,
            toneMapped: false,
            depthWrite: true
        }));
        windStreamParticles.frustumCulled = false;
        scene.add(windStreamParticles);

        let windParticleIndex = 0;
        function spawnWindStream(pos, direction, speed, life = 0.6) {
            const idx = windParticleIndex % windStreamCount;
            const trailLen = 2.5 + Math.random() * 1.0; // Increased trail length

            windStreamPos[idx * 6] = pos.x;
            windStreamPos[idx * 6 + 1] = pos.y;
            windStreamPos[idx * 6 + 2] = pos.z;

            windStreamPos[idx * 6 + 3] = pos.x + direction.x * speed * trailLen;
            windStreamPos[idx * 6 + 4] = pos.y + direction.y * speed * trailLen;
            windStreamPos[idx * 6 + 5] = pos.z + direction.z * speed * trailLen;

            windStreamVel[idx] = {
                x: pos.x,
                y: pos.y,
                z: pos.z,
                dirX: direction.x * speed,
                dirY: direction.y * speed,
                dirZ: direction.z * speed,
                trailLen: trailLen
            };
            windStreamLife[idx] = 0;
            windStreamMaxLife[idx] = life;
            windParticleIndex++;
        }
        // ── Pinwheel Configuration ────────────────────────────────────────────────────
        const pinwheelCount = 400;
        const pinwheelColors = [0xff4081, 0xffeb3b, 0x4caf50, 0x2196f3];

        // Custom curved blade geometry
        const bladeGeo = new THREE.PlaneGeometry(0.6, 0.6, 4, 4);
        bladeGeo.translate(0.3, 0.3, 0);
        const bladePos = bladeGeo.attributes.position;
        for (let i = 0; i < bladePos.count; i++) {
            let x = bladePos.getX(i);
            let y = bladePos.getY(i);
            let z = (x * y) * 0.4;
            bladePos.setZ(i, z);
        }
        bladeGeo.computeVertexNormals();
        bladeGeo.rotateX(0.2);

        // Create 4 InstancedMeshes for each wing color
        const pinwheelBlades = [];
        for (let i = 0; i < 4; i++) {
            const mat = new THREE.MeshStandardMaterial({
                color: pinwheelColors[i],
                side: THREE.DoubleSide,
                roughness: 0.2,
                metalness: 0.1
            });
            const mesh = new THREE.InstancedMesh(bladeGeo, mat, pinwheelCount);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            scene.add(mesh);
            pinwheelBlades.push(mesh);
        }

        // Pinwheel Hubs
        const pinwheelHubGeo = new THREE.SphereGeometry(0.08, 16, 16);
        const pinwheelHubMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.4 });
        const pinwheelHubs = new THREE.InstancedMesh(pinwheelHubGeo, pinwheelHubMat, pinwheelCount);
        scene.add(pinwheelHubs);

        // Pinwheel Particle State Data
        const pinwheelPositions = new Float32Array(pinwheelCount * 3);
        const pinwheelPhases = new Float32Array(pinwheelCount);
        const pinwheelSpeeds = new Float32Array(pinwheelCount);
        const pinwheelSpinSpeeds = new Float32Array(pinwheelCount);
        const pinwheelOrientations = new Float32Array(pinwheelCount * 3);

        for (let i = 0; i < pinwheelCount; i++) {
            // Split between left and right sides (x < -40 or x > 40)
            const isLeft = Math.random() > 0.5;
            pinwheelPositions[i * 3] = isLeft ? (Math.random() * -20 - 40) : (Math.random() * 20 + 40);
            pinwheelPositions[i * 3 + 1] = Math.random() * 30 + 2;
            pinwheelPositions[i * 3 + 2] = (Math.random() - 0.5) * 80;

            pinwheelPhases[i] = Math.random() * Math.PI * 2;
            pinwheelSpeeds[i] = Math.random() * 0.4 + 0.1;
            pinwheelSpinSpeeds[i] = Math.random() * 8 + 4;

            pinwheelOrientations[i * 3] = (Math.random() - 0.5) * Math.PI * 0.5;
            pinwheelOrientations[i * 3 + 1] = Math.random() * Math.PI * 2;
            pinwheelOrientations[i * 3 + 2] = (Math.random() - 0.5) * Math.PI * 0.5;
        }

        // Ambient Dust for pinwheel area
        const pinwheelDustGeo = new THREE.BufferGeometry();
        const pinwheelDustPos = new Float32Array(1000 * 3);
        for (let i = 0; i < 3000; i++) {
            pinwheelDustPos[i] = (Math.random() - 0.5) * 100;
        }
        pinwheelDustGeo.setAttribute('position', new THREE.BufferAttribute(pinwheelDustPos, 3));
        const pinwheelDustMat = new THREE.PointsMaterial({
            color: 0xffffff,
            size: 0.15,
            transparent: true,
            opacity: 0.6
        });
        const pinwheelDust = new THREE.Points(pinwheelDustGeo, pinwheelDustMat);
        scene.add(pinwheelDust);

        // ── Lights ────────────────────────────────────────────────────────────────────
        scene.add(new THREE.AmbientLight(0xffccff, 1.0));
        const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
        dirLight.position.set(10, 20, 10); dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = dirLight.shadow.mapSize.height = 2048;
        dirLight.shadow.camera.left = -20; dirLight.shadow.camera.right = 20;
        dirLight.shadow.camera.top = 20; dirLight.shadow.camera.bottom = -20;
        scene.add(dirLight);
        const pinkLight = new THREE.PointLight(0xff66b2, 2, 20);
        const blueLight = new THREE.PointLight(0x66b2ff, 2, 20);
        scene.add(pinkLight, blueLight);

        // ── Materials ─────────────────────────────────────────────────────────────────
        const ghostMat = new THREE.MeshStandardMaterial({ color: 0xF2AEBB, roughness: 0.4 });
        const blackMat = new THREE.MeshBasicMaterial({ color: 0x111111 });

        const blushMat = new THREE.MeshBasicMaterial({ color: 0xff6699, transparent: true, opacity: 0.5 });
        const suitMat = new THREE.MeshStandardMaterial({ color: 0x000000, roughness: 0.7 });
        const whiteMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.5 });
        const yellowMat = new THREE.MeshStandardMaterial({ color: 0xFFD700, roughness: 0.4, metalness: 0.2 });
        const beakMat = new THREE.MeshStandardMaterial({ color: 0xff8800 });
        const vestMat = new THREE.MeshStandardMaterial({ color: 0x000000, roughness: 0.7, metalness: 0.2 });
        const sunglassMat = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 0.1, metalness: 0.8 });
        const goldMat = new THREE.MeshStandardMaterial({ color: 0xFFD700, roughness: 0.3, metalness: 0.9 });
        const matShirt = new THREE.MeshStandardMaterial({ color: 0xFFD150, roughness: 0.5 });
        const matTie = new THREE.MeshStandardMaterial({ color: 0xF8843F, roughness: 0.6 });
        const matFeather = new THREE.MeshStandardMaterial({ color: 0xFFD700, roughness: 0.4, metalness: 0.1 });
        const matBlack = new THREE.MeshBasicMaterial({ color: 0x111111 });

        // ── GHOST ─────────────────────────────────────────────────────────────────────
        const ghostGroup = new THREE.Group();
        scene.add(ghostGroup);

        const bodyGeo = new THREE.CapsuleGeometry(1.2, 2, 20, 20);
        {
            const pos = bodyGeo.attributes.position, v = new THREE.Vector3();
            for (let i = 0; i < pos.count; i++) {
                v.fromBufferAttribute(pos, i);
                if (v.y < -0.1) {
                    const a = Math.atan2(v.z, v.x), r = Math.sqrt(v.x * v.x + v.z * v.z);
                    v.y += Math.sin(a * 6) * 0.9 * (1 - r / 1.2); pos.setXYZ(i, v.x, v.y, v.z);
                }
            }
            pos.needsUpdate = true; bodyGeo.computeVertexNormals();
        }
        bodyGeo.computeBoundingBox();
        const bottomOffset = -bodyGeo.boundingBox.min.y;

        const ghostBody = new THREE.Mesh(bodyGeo, ghostMat);
        ghostBody.castShadow = true; ghostGroup.add(ghostBody);

        const armGeo = new THREE.CapsuleGeometry(0.25, 0.8, 16, 16);
        const leftArm = new THREE.Mesh(armGeo, ghostMat);
        leftArm.position.set(-1.3, 0.2, 0.5); leftArm.rotation.set(Math.PI / 4, 0, -Math.PI / 6); leftArm.castShadow = true; ghostBody.add(leftArm);
        const rightArm = new THREE.Mesh(armGeo, ghostMat);
        rightArm.position.set(1.3, 0.2, 0.5); rightArm.rotation.set(Math.PI / 4, 0, Math.PI / 6); rightArm.castShadow = true; ghostBody.add(rightArm);

        const faceGroup = new THREE.Group();
        faceGroup.position.set(0, 0.5, 1.15); ghostBody.add(faceGroup);
        const eyeGeo = new THREE.CapsuleGeometry(0.1, 0.15, 16, 16);
        const leftEye = new THREE.Mesh(eyeGeo, blackMat); leftEye.position.set(-0.4, 0.2, 0); leftEye.rotation.z = Math.PI / 2; faceGroup.add(leftEye);
        const rightEye = new THREE.Mesh(eyeGeo, blackMat); rightEye.position.set(0.4, 0.2, 0); rightEye.rotation.z = Math.PI / 2; faceGroup.add(rightEye);

        // Eyelashes - curved like the image (extending from top-outer edge of eyes)
        const eyelashes = [];
        // Left eye eyelash - curved, extending upward and inward
        const leftEyelashGeo = new THREE.CylinderGeometry(0.015, 0.02, 0.25, 8);
        const leftEyelash = new THREE.Mesh(leftEyelashGeo, blackMat);
        leftEyelash.position.set(-0.4, 0.4, 0.05);
        leftEyelash.rotation.set(Math.PI / 2, 0, -Math.PI / 6); // Curved upward and inward
        leftEyelash.scale.set(1.5, 1.5, 1.2); // Make it longer
        faceGroup.add(leftEyelash);
        eyelashes.push({ mesh: leftEyelash, side: 'left' });

        // Right eye eyelash - curved, extending upward and inward
        const rightEyelashGeo = new THREE.CylinderGeometry(0.015, 0.02, 0.25, 8);
        const rightEyelash = new THREE.Mesh(rightEyelashGeo, blackMat);
        rightEyelash.position.set(0.4, 0.4, 0.05);
        rightEyelash.rotation.set(Math.PI / 2, 0, Math.PI / 6); // Curved upward and inward (mirrored)
        rightEyelash.scale.set(1.5, 1.5, 1.2); // Make it longer
        faceGroup.add(rightEyelash);
        eyelashes.push({ mesh: rightEyelash, side: 'right' });

        const blushGeo = new THREE.CircleGeometry(0.2, 32);
        const lb = new THREE.Mesh(blushGeo, blushMat); lb.position.set(-0.6, -0.1, 0.05); lb.rotation.y = -0.2; faceGroup.add(lb);
        const rb2 = new THREE.Mesh(blushGeo, blushMat); rb2.position.set(0.6, -0.1, 0.05); rb2.rotation.y = 0.2; faceGroup.add(rb2);
        const mouthGeo = new THREE.TorusGeometry(0.15, 0.04, 16, 32, Math.PI);
        const mouth = new THREE.Mesh(mouthGeo, blackMat); mouth.position.set(0, -0.1, 0.05); mouth.rotation.x = Math.PI; faceGroup.add(mouth);
        const tearGeo = new THREE.SphereGeometry(0.08, 16, 16);
        const tearMat = new THREE.MeshStandardMaterial({ color: 0x66ccff, transparent: true, opacity: 0.8 });
        const tears = [];
        for (let i = 0; i < 4; i++) { const t = new THREE.Mesh(tearGeo, tearMat); t.visible = false; faceGroup.add(t); tears.push({ mesh: t, yOffset: 0, isLeft: i % 2 === 0 }); }

        let currentExpression = 'neutral';
        function setExpression(exp) {
            currentExpression = exp;
            leftEye.rotation.z = Math.PI / 2; rightEye.rotation.z = Math.PI / 2;
            leftEye.scale.set(1, 1, 1); rightEye.scale.set(1, 1, 1);
            mouth.rotation.set(Math.PI, 0, 0); mouth.position.y = -0.1;
            tears.forEach(t => t.mesh.visible = false);

            // Animate eyelashes based on emotion
            if (exp === 'sad') {
                leftEye.rotation.z -= 0.2; rightEye.rotation.z += 0.2; mouth.rotation.x = 0; mouth.position.y = -0.2;
                // Eyelashes droop down more (sad)
                leftEyelash.rotation.set(Math.PI / 2 + 0.3, 0, -Math.PI / 6 - 0.2);
                rightEyelash.rotation.set(Math.PI / 2 + 0.3, 0, Math.PI / 6 + 0.2);
                leftEyelash.position.y = 0.35;
                rightEyelash.position.y = 0.35;
            }
            else if (exp === 'smile') {
                leftEye.scale.x = 0.2; rightEye.scale.x = 0.2;
                // Eyelashes curve up more (happy)
                leftEyelash.rotation.set(Math.PI / 2 - 0.2, 0, -Math.PI / 6);
                rightEyelash.rotation.set(Math.PI / 2 - 0.2, 0, Math.PI / 6);
                leftEyelash.position.y = 0.45;
                rightEyelash.position.y = 0.45;
            }
            else if (exp === 'crying') {
                leftEye.rotation.z -= 0.3; rightEye.rotation.z += 0.3; mouth.rotation.x = 0; mouth.position.y = -0.2;
                tears.forEach(t => { t.mesh.visible = true; t.yOffset = Math.random() * 0.5; });
                // Eyelashes droop down even more (crying)
                leftEyelash.rotation.set(Math.PI / 2 + 0.4, 0, -Math.PI / 6 - 0.3);
                rightEyelash.rotation.set(Math.PI / 2 + 0.4, 0, Math.PI / 6 + 0.3);
                leftEyelash.position.y = 0.3;
                rightEyelash.position.y = 0.3;
            }
            else {
                // Neutral - default position
                leftEyelash.rotation.set(Math.PI / 2, 0, -Math.PI / 6);
                rightEyelash.rotation.set(Math.PI / 2, 0, Math.PI / 6);
                leftEyelash.position.y = 0.4;
                rightEyelash.position.y = 0.4;
            }
        }

        // ── BOSS DUCK ─────────────────────────────────────────────────────────────────
        const duckGroup = new THREE.Group();
        duckGroup.position.set(5, 0, 5);
        scene.add(duckGroup);

        const bodyGroup = new THREE.Group();
        duckGroup.add(bodyGroup);
        const legsGroup = new THREE.Group();
        legsGroup.position.set(0, 0, 0);
        duckGroup.add(legsGroup);

        // --- Suit Body ---
        const duckBodyGeo = new THREE.CapsuleGeometry(0.52, 0.8, 10, 10);
        const bodyMesh = new THREE.Mesh(duckBodyGeo, suitMat);
        bodyMesh.rotation.z = Math.PI / 2;
        bodyMesh.rotation.x = Math.PI / 2;
        bodyMesh.position.y = 1.6;
        bodyMesh.castShadow = true;
        bodyGroup.add(bodyMesh);

        // Tail part of suit
        const duckTailGeo = new THREE.ConeGeometry(0.4, 0.8, 14);
        const tailMesh = new THREE.Mesh(duckTailGeo, suitMat);
        tailMesh.rotation.x = -Math.PI / 2;
        tailMesh.position.set(0, 1.6, -0.8);
        tailMesh.castShadow = true;
        bodyGroup.add(tailMesh);

        // Black Vest over suit
        const duckVestGeo = new THREE.BoxGeometry(0.50, 1, 0.3);
        const duckVestMesh = new THREE.Mesh(duckVestGeo, vestMat);
        duckVestMesh.position.set(0, 1.5, 0.5);
        duckVestMesh.castShadow = true;
        bodyGroup.add(duckVestMesh);

        // --- Shirt & Tie ---
        const duckShirtGeo = new THREE.PlaneGeometry(0.02, 0.02);
        const shirtMesh = new THREE.Mesh(duckShirtGeo, matShirt);
        shirtMesh.position.set(0, 1.7, 0.65);
        shirtMesh.rotation.x = -Math.PI / 6;
        bodyGroup.add(shirtMesh);

        // Collar
        const duckCollarGeo = new THREE.CylinderGeometry(0.2, 0.4, 0.2, 16);
        const collarMesh = new THREE.Mesh(duckCollarGeo, matShirt);
        collarMesh.position.set(0, 2.05, 0.5);
        collarMesh.rotation.x = Math.PI / 8;
        bodyGroup.add(collarMesh);

        // Tie
        const duckTieGeo = new THREE.BoxGeometry(0.15, 0.7, 0.05);
        const tieMesh = new THREE.Mesh(duckTieGeo, matTie);
        tieMesh.position.set(0, 1.5, 0.7);
        tieMesh.rotation.x = -Math.PI / 8;
        bodyGroup.add(tieMesh);

        // --- Neck & Head ---
        const neckGroup = new THREE.Group();
        neckGroup.position.set(0, 2.0, 0.4);
        bodyGroup.add(neckGroup);

        const duckNeckGeo = new THREE.CylinderGeometry(0.15, 0.25, 1.2, 16);
        const neckMesh = new THREE.Mesh(duckNeckGeo, matFeather);
        neckMesh.position.set(0, 0.5, 0.2);
        neckMesh.rotation.x = Math.PI / 12;
        neckMesh.castShadow = true;
        neckGroup.add(neckMesh);

        const duckHeadGeo = new THREE.SphereGeometry(0.35, 16, 16);
        const headMesh = new THREE.Mesh(duckHeadGeo, matFeather);
        headMesh.position.set(0, 1.1, 0.3);
        headMesh.castShadow = true;
        neckGroup.add(headMesh);

        // Beak
        const duckBeakHeadGeo = new THREE.BoxGeometry(0.2, 0.15, 0.5);
        const beakHeadPos = duckBeakHeadGeo.attributes.position;
        for (let i = 0; i < beakHeadPos.count; i++) {
            if (beakHeadPos.getZ(i) > 0) {
                beakHeadPos.setX(i, beakHeadPos.getX(i) * 0.5);
                beakHeadPos.setY(i, beakHeadPos.getY(i) * 0.5);
            }
        }
        duckBeakHeadGeo.computeVertexNormals();
        const beakHeadMesh = new THREE.Mesh(duckBeakHeadGeo, beakMat);
        beakHeadMesh.position.set(0, 1.1, 0.65);
        beakHeadMesh.castShadow = true;
        neckGroup.add(beakHeadMesh);

        // --- Pixel Sunglasses ("Deal With It" style) ---
        const glassesGroup = new THREE.Group();
        const pixelSize = 0.04;
        const duckPixelGeo = new THREE.BoxGeometry(pixelSize, pixelSize, pixelSize);

        const lensPattern = [
            [1, 1, 1, 1, 1],
            [1, 1, 1, 1, 1],
            [0, 1, 1, 1, 0]
        ];

        const buildLens = (offsetX) => {
            for (let y = 0; y < lensPattern.length; y++) {
                for (let x = 0; x < lensPattern[y].length; x++) {
                    if (lensPattern[y][x] === 1) {
                        const p = new THREE.Mesh(duckPixelGeo, matBlack);
                        p.position.set(
                            offsetX + (x * pixelSize) - (lensPattern[0].length * pixelSize / 2),
                            -y * pixelSize,
                            0
                        );
                        glassesGroup.add(p);
                    }
                }
            }
        };

        buildLens(-0.15);
        buildLens(0.15);

        const duckBridgeGlasses = new THREE.Mesh(new THREE.BoxGeometry(0.1, pixelSize, pixelSize), matBlack);
        glassesGroup.add(duckBridgeGlasses);

        const duckArmGeoGlasses = new THREE.BoxGeometry(pixelSize * 0.7, pixelSize * 0.7, 0.3);
        const duckLeftArmGlasses = new THREE.Mesh(duckArmGeoGlasses, matBlack);
        duckLeftArmGlasses.position.set(-0.25, 0, -0.15);
        glassesGroup.add(duckLeftArmGlasses);
        const duckRightArmGlasses = new THREE.Mesh(duckArmGeoGlasses, matBlack);
        duckRightArmGlasses.position.set(0.25, 0, -0.15);
        glassesGroup.add(duckRightArmGlasses);

        glassesGroup.position.set(0, 1.30, 0.8);
        glassesGroup.rotation.x = Math.PI / 16;
        neckGroup.add(glassesGroup);

        // --- Legs (Suit Pants) & Shoes ---
        const duckLegGeoNew = new THREE.CylinderGeometry(0.2, 0.15, 1.5, 16);
        const duckShoeGeoNew = new THREE.BoxGeometry(0.25, 0.15, 0.4);

        const createLeg = (xOffset) => {
            const leg = new THREE.Group();

            const pant = new THREE.Mesh(duckLegGeoNew, suitMat);
            pant.position.y = 0.7;
            pant.castShadow = true;
            leg.add(pant);

            const shoe = new THREE.Mesh(duckShoeGeoNew, yellowMat);
            shoe.position.set(0, 0.050, 0.2);
            shoe.castShadow = true;
            leg.add(shoe);

            leg.position.set(xOffset, 0, 0);
            return leg;
        };

        const leftLeg = createLeg(-0.3);
        const rightLeg = createLeg(0.3);
        legsGroup.add(leftLeg);
        legsGroup.add(rightLeg);

        // Store references for animation
        const neckPivot = neckGroup;
        const headGroup = neckGroup;

        // ── SNAKE NECK TUBE ───────────────────────────────────────────────────────────
        // Simple floating head for hugging interaction
        const floatingHead = new THREE.Group();
        scene.add(floatingHead);
        floatingHead.visible = false;

        const fhHeadNew = new THREE.Mesh(new THREE.SphereGeometry(0.35, 16, 16), matFeather);
        fhHeadNew.position.set(0, 1.1, 0.3);
        floatingHead.add(fhHeadNew);

        const fhBeakHeadGeo = new THREE.BoxGeometry(0.2, 0.15, 0.5);
        const fhBeakHeadPos = fhBeakHeadGeo.attributes.position;
        for (let i = 0; i < fhBeakHeadPos.count; i++) {
            if (fhBeakHeadPos.getZ(i) > 0) {
                fhBeakHeadPos.setX(i, fhBeakHeadPos.getX(i) * 0.5);
                fhBeakHeadPos.setY(i, fhBeakHeadPos.getY(i) * 0.5);
            }
        }
        fhBeakHeadGeo.computeVertexNormals();
        const fhBeakHeadMesh = new THREE.Mesh(fhBeakHeadGeo, beakMat);
        fhBeakHeadMesh.position.set(0, 1.1, 0.65);
        floatingHead.add(fhBeakHeadMesh);

        const NUM_CP = 7;
        const neckCP = Array.from({ length: NUM_CP }, () => new THREE.Vector3());
        let tubeMesh = null;

        function rebuildTube(points) {
            if (tubeMesh) { scene.remove(tubeMesh); tubeMesh.geometry.dispose(); tubeMesh = null; }
            const filtered = [];
            for (let i = 0; i < points.length; i++) {
                if (i === 0 || points[i].distanceTo(points[i - 1]) > 0.05) filtered.push(points[i].clone());
            }
            if (filtered.length < 2) return;
            if (filtered.length === 2) filtered.splice(1, 0, new THREE.Vector3().lerpVectors(filtered[0], filtered[1], 0.5));
            try {
                const curve = new THREE.CatmullRomCurve3(filtered, false, 'catmullrom', 0.5);
                const geo = new THREE.TubeGeometry(curve, filtered.length * 4, 0.32, 10, false);
                tubeMesh = new THREE.Mesh(geo, yellowMat);
                tubeMesh.castShadow = true;
                scene.add(tubeMesh);
            } catch (e) { }
        }

        // ── Input ─────────────────────────────────────────────────────────────────────
        const keys = {};
        let closestCharIndex = -1;
        let isNewCharClose = false;
        const INTERACTION_DISTANCE = 8; // Distance to trigger interaction
        let newCharSound = null; // Audio element for new character sound
        let angleSound = null; // Audio element for angle.glb sound
        let isAngleSoundPlaying = false; // Track if ang.mp3 is playing
        let angleSongPlayer = null; // Audio element for angle.glb custom song
        let isAngleSongPlaying = false; // Track if custom song is playing
        let fatSound = null; // Audio element for fat.glb sound
        const fatMessages = [
            "You shuold sing well like her",
            "You must always be nice infront of camera",
            "Getting closer and more fan like her",
            "Or i will find some girl replace you in bands."
        ];
        let fatCurrentMessageIndex = 0;
        let fatLastMessageChangeTime = 0;
        let lmSound = null; // Audio element for lm.glb sound
        const lmMessages = [
            "Do u want join some party with ....",
            "U can meet alot of .....",
            "Some drink will make u happy and sing better ..."
        ];
        let lmCurrentMessageIndex = 0;
        let lmLastMessageChangeTime = 0;

        window.addEventListener('keydown', e => {
            keys[e.key.toLowerCase()] = true;
            if (e.key === 'j') setExpression('sad');
            if (e.key === 'k') setExpression('smile');
            if (e.key === 'l') setExpression('crying');

            // Handle F key for character interaction
            if (e.key.toLowerCase() === 'f') {
                // Check pink characters first
                if (closestCharIndex >= 0) {
                    const char = characterModels[closestCharIndex];
                    if (char) {
                        // Special handling for angle.glb (index 5, char6)
                        if (closestCharIndex === 5) {
                            // Set interacting state to show chat bubble
                            char.isInteracting = true;

                            // Get chat bubble element
                            const chatEl = document.getElementById(`char${closestCharIndex + 1}-chat`);
                            if (chatEl) {
                                chatEl.style.display = 'block';
                            }

                            // Play ang.mp3 and stop bg music
                            if (!angleSound) {
                                angleSound = new Audio('ang.mp3');
                                angleSound.volume = 0.7;
                            }

                            // Set up event listener for when sound ends (only once)
                            if (!angleSound.hasEndedListener) {
                                angleSound.addEventListener('ended', () => {
                                    isAngleSoundPlaying = false;
                                    if (bgMusic && isMusicPlaying) {
                                        bgMusic.volume = 0.3;
                                        bgMusic.play().catch(e => console.log('BG music resume error:', e));
                                    }
                                    // Hide chat bubble when sound ends
                                    const chatElEnd = document.getElementById(`char${closestCharIndex + 1}-chat`);
                                    if (chatElEnd) {
                                        chatElEnd.style.display = 'none';
                                    }
                                    if (char) {
                                        char.isInteracting = false;
                                    }
                                });
                                angleSound.hasEndedListener = true;
                            }

                            // Stop bg music immediately and forcefully
                            if (bgMusic) {
                                bgMusic.pause();
                                bgMusic.currentTime = 0; // Reset to beginning
                                bgMusic.volume = 0; // Mute it
                            }

                            // Mark that ang.mp3 is playing
                            isAngleSoundPlaying = true;

                            // Play ang.mp3
                            angleSound.currentTime = 0;
                            angleSound.play().catch(e => console.log('Angle sound play error:', e));

                            // Hide notification
                            const notifEl = document.getElementById('angle-notif');
                            if (notifEl) {
                                notifEl.style.display = 'none';
                            }
                        } else if (closestCharIndex === 8) {
                            // Special handling for lm.glb (index 8)
                            // Play evil.mp3
                            if (!lmSound) {
                                lmSound = new Audio('evil.mp3');
                                lmSound.volume = 0.7;
                            }
                            lmSound.currentTime = 0;
                            lmSound.play().catch(e => console.log('LM sound play error:', e));

                            // Hide notification
                            const notifEl = document.getElementById('lm-notif');
                            if (notifEl) {
                                notifEl.style.display = 'none';
                            }
                        } else if (closestCharIndex === 9) {
                            // Special handling for fat.glb (index 9)
                            // Play angry.mp3
                            if (!fatSound) {
                                fatSound = new Audio('angry.mp3');
                                fatSound.volume = 0.7;
                            }
                            fatSound.currentTime = 0;
                            fatSound.play().catch(e => console.log('Fat sound play error:', e));

                            // Hide notification
                            const notifEl = document.getElementById('fat-notif');
                            if (notifEl) {
                                notifEl.style.display = 'none';
                            }
                        } else if (!char.isInteracting) {
                            // Normal interaction for other characters
                            char.isInteracting = true;
                            // Show chat bubble
                            const chatEl = document.getElementById(`char${closestCharIndex + 1}-chat`);
                            if (chatEl) {
                                chatEl.style.display = 'block';
                            }
                            // Clear any existing timeout for this character
                            if (characterTimeouts[closestCharIndex]) {
                                clearTimeout(characterTimeouts[closestCharIndex]);
                            }
                            // Hide chat after 3 seconds
                            characterTimeouts[closestCharIndex] = setTimeout(() => {
                                if (chatEl) chatEl.style.display = 'none';
                                char.isInteracting = false;
                                characterTimeouts[closestCharIndex] = null;
                            }, 3000);

                            // Hide notification
                            const notifEl = document.getElementById(`char${closestCharIndex + 1}-notif`);
                            if (notifEl) {
                                notifEl.style.display = 'none';
                            }
                        }
                    }
                }
                // Check new character (ld.glb)
                else if (isNewCharClose && newCharacterGroup) {
                    // Play sound
                    if (!newCharSound) {
                        newCharSound = new Audio('soundmeme.mp3');
                        newCharSound.volume = 0.7;
                    }
                    newCharSound.currentTime = 0;
                    newCharSound.play().catch(e => console.log('Sound play error:', e));

                    // Hide notification
                    const notifEl = document.getElementById('newchar-notif');
                    if (notifEl) {
                        notifEl.style.display = 'none';
                    }
                }
            }

            // Handle Q key for angle.glb song input
            if (e.key.toLowerCase() === 'q') {
                if (closestCharIndex === 5) {
                    // angle.glb - show message and prompt for song URL
                    const char = characterModels[5];
                    if (char) {
                        // Check if song is already playing - if so, stop it
                        const embedIframe = document.getElementById('angle-song-embed');
                        const embedContainer = document.getElementById('angle-song-embed-container');
                        if (isAngleSongPlaying && (angleSongPlayer || (embedIframe && embedIframe.src))) {
                            // Stop current song
                            if (angleSongPlayer) {
                                angleSongPlayer.pause();
                                angleSongPlayer = null;
                            }
                            if (embedIframe) {
                                embedIframe.src = '';
                            }
                            if (embedContainer) {
                                embedContainer.style.display = 'none';
                            }
                            // Clear embed check interval if exists
                            if (window.angleEmbedCheckInterval) {
                                clearInterval(window.angleEmbedCheckInterval);
                                window.angleEmbedCheckInterval = null;
                            }
                            // Remove message listener if exists
                            if (window.angleEmbedMessageHandler) {
                                window.removeEventListener('message', window.angleEmbedMessageHandler);
                                window.angleEmbedMessageHandler = null;
                            }
                            isAngleSongPlaying = false;
                            // Resume bg music
                            if (bgMusic && isMusicPlaying) {
                                bgMusic.volume = 0.3;
                                bgMusic.play().catch(err => console.log('BG music resume error:', err));
                            }
                            // Hide chat
                            const chatEl = document.getElementById('angle-chat');
                            if (chatEl) {
                                chatEl.style.display = 'none';
                            }
                            char.isInteracting = false;
                            return; // Exit early
                        }

                        // Show message
                        const chatEl = document.getElementById('angle-chat');
                        if (chatEl) {
                            chatEl.textContent = "Give me song and i will sing for u";
                            chatEl.style.display = 'block';
                            char.isInteracting = true;
                        }

                        // Hide Q notification
                        const qNotifEl = document.getElementById('angle-q-notif');
                        if (qNotifEl) {
                            qNotifEl.style.display = 'none';
                        }

                        // Show custom URL input modal
                        const showUrlInput = () => {
                            return new Promise((resolve) => {
                                const modal = document.getElementById('url-input-modal');
                                const inputField = document.getElementById('url-input-field');
                                const okBtn = document.getElementById('url-input-ok');
                                const cancelBtn = document.getElementById('url-input-cancel');
                                
                                // Show modal
                                modal.style.display = 'flex';
                                inputField.value = '';
                                inputField.focus();
                                
                                // Handle OK button
                                const handleOk = () => {
                                    const url = inputField.value.trim();
                                    modal.style.display = 'none';
                                    okBtn.removeEventListener('click', handleOk);
                                    cancelBtn.removeEventListener('click', handleCancel);
                                    inputField.removeEventListener('keypress', handleEnter);
                                    resolve(url);
                                };
                                
                                // Handle Cancel button
                                const handleCancel = () => {
                                    modal.style.display = 'none';
                                    okBtn.removeEventListener('click', handleOk);
                                    cancelBtn.removeEventListener('click', handleCancel);
                                    inputField.removeEventListener('keypress', handleEnter);
                                    resolve(null);
                                };
                                
                                // Handle Enter key
                                const handleEnter = (e) => {
                                    if (e.key === 'Enter') {
                                        handleOk();
                                    }
                                };
                                
                                okBtn.addEventListener('click', handleOk);
                                cancelBtn.addEventListener('click', handleCancel);
                                inputField.addEventListener('keypress', handleEnter);
                            });
                        };
                        
                        showUrlInput().then(songUrl => {
                            if (songUrl && songUrl.trim() !== '') {
                                const url = songUrl.trim();

                            // Stop any existing song
                            const embedIframe = document.getElementById('angle-song-embed');
                            const embedContainer = document.getElementById('angle-song-embed-container');
                            if (angleSongPlayer) {
                                angleSongPlayer.pause();
                                angleSongPlayer = null;
                            }
                            if (embedIframe) {
                                embedIframe.src = '';
                            }
                            if (embedContainer) {
                                embedContainer.style.display = 'none';
                            }
                            // Clear embed check interval if exists
                            if (window.angleEmbedCheckInterval) {
                                clearInterval(window.angleEmbedCheckInterval);
                                window.angleEmbedCheckInterval = null;
                            }

                            // Stop bg music
                            if (bgMusic) {
                                bgMusic.pause();
                                bgMusic.volume = 0;
                            }

                            // Detect URL type and handle accordingly
                            let embedUrl = null;
                            let isEmbed = false;

                            // YouTube URL detection - handle both URLs and iframe embed code
                            if (url.includes('youtube.com') || url.includes('youtu.be') || url.includes('<iframe')) {
                                isEmbed = true;
                                let videoId = '';
                                
                                // Check if user pasted iframe embed code
                                if (url.includes('<iframe')) {
                                    // Extract video ID from iframe src attribute
                                    const iframeMatch = url.match(/youtube\.com\/embed\/([a-zA-Z0-9_-]{11})/);
                                    if (iframeMatch && iframeMatch[1]) {
                                        videoId = iframeMatch[1];
                                    } else {
                                        // Try alternative patterns
                                        const altMatch = url.match(/embed\/([a-zA-Z0-9_-]{11})/);
                                        if (altMatch && altMatch[1]) {
                                            videoId = altMatch[1];
                                        }
                                    }
                                }
                                // Handle regular YouTube URLs
                                else if (url.includes('youtube.com/watch?v=')) {
                                    videoId = url.split('v=')[1]?.split('&')[0]?.split('#')[0]?.trim();
                                } else if (url.includes('youtu.be/')) {
                                    videoId = url.split('youtu.be/')[1]?.split('?')[0]?.split('&')[0]?.split('#')[0]?.trim();
                                } else if (url.includes('youtube.com/embed/')) {
                                    videoId = url.split('embed/')[1]?.split('?')[0]?.split('&')[0]?.split('#')[0]?.trim();
                                }
                                
                                // Clean and validate video ID
                                if (videoId) {
                                    videoId = videoId.replace(/[^a-zA-Z0-9_-]/g, ''); // Remove invalid characters
                                    if (videoId.length >= 11) {
                                        videoId = videoId.substring(0, 11); // Take first 11 characters
                                    }
                                }
                                
                                if (videoId && videoId.length === 11) {
                                    // YouTube video IDs are always 11 characters
                                    // Use proper YouTube embed URL with all necessary parameters
                                    embedUrl = `https://www.youtube.com/embed/${videoId}?autoplay=1&mute=0&controls=1&enablejsapi=1&origin=${encodeURIComponent(window.location.origin)}&rel=0&modestbranding=1`;
                                } else if (videoId) {
                                    // Try anyway if video ID exists but not exactly 11 chars (might be playlist or other format)
                                    embedUrl = `https://www.youtube.com/embed/${videoId}?autoplay=1&mute=0&controls=1&enablejsapi=1&origin=${encodeURIComponent(window.location.origin)}&rel=0&modestbranding=1`;
                                }
                            }
                            // Spotify URL detection - handle both URLs and iframe embed code
                            else if (url.includes('spotify.com') || (url.includes('<iframe') && url.includes('spotify'))) {
                                isEmbed = true;
                                let spotifyId = '';
                                let spotifyType = '';
                                
                                // Check if user pasted iframe embed code
                                if (url.includes('<iframe')) {
                                    const trackMatch = url.match(/spotify\.com\/embed\/(track|album|playlist)\/([a-zA-Z0-9]+)/);
                                    if (trackMatch && trackMatch[1] && trackMatch[2]) {
                                        spotifyType = trackMatch[1];
                                        spotifyId = trackMatch[2];
                                    }
                                }
                                
                                // Handle regular Spotify URLs
                                if (!spotifyId) {
                                    if (url.includes('track/')) {
                                        spotifyType = 'track';
                                        spotifyId = url.split('track/')[1]?.split('?')[0]?.split('/')[0];
                                    } else if (url.includes('album/')) {
                                        spotifyType = 'album';
                                        spotifyId = url.split('album/')[1]?.split('?')[0]?.split('/')[0];
                                    } else if (url.includes('playlist/')) {
                                        spotifyType = 'playlist';
                                        spotifyId = url.split('playlist/')[1]?.split('?')[0]?.split('/')[0];
                                    }
                                }
                                
                                if (spotifyId && spotifyType) {
                                    embedUrl = `https://open.spotify.com/embed/${spotifyType}/${spotifyId}?utm_source=generator&autoplay=true`;
                                }
                            }
                            // SoundCloud URL detection - handle both URLs and iframe embed code
                            else if (url.includes('soundcloud.com') || (url.includes('<iframe') && url.includes('soundcloud'))) {
                                isEmbed = true;
                                let soundcloudUrl = url;
                                
                                // Check if user pasted iframe embed code
                                if (url.includes('<iframe')) {
                                    // Extract URL from iframe src attribute
                                    const urlMatch = url.match(/url=([^&"']+)/);
                                    if (urlMatch && urlMatch[1]) {
                                        soundcloudUrl = decodeURIComponent(urlMatch[1]);
                                    } else {
                                        // Try to extract from soundcloud.com URL in the iframe
                                        const scMatch = url.match(/soundcloud\.com\/[^"'\s]+/);
                                        if (scMatch && scMatch[0]) {
                                            soundcloudUrl = 'https://' + scMatch[0];
                                        }
                                    }
                                }
                                
                                // SoundCloud embed format
                                embedUrl = `https://w.soundcloud.com/player/?url=${encodeURIComponent(soundcloudUrl)}&auto_play=true&hide_related=false&show_comments=true&show_user=true&show_reposts=false&visual=true`;
                            }

                            if (isEmbed && embedUrl && embedIframe) {
                                // Use iframe embed for YouTube, Spotify, SoundCloud
                                isAngleSongPlaying = true;
                                embedIframe.src = embedUrl;

                                // Get container element
                                const embedContainer = document.getElementById('angle-song-embed-container');

                                // Function to close embed and resume bg music
                                function closeEmbed() {
                                    embedIframe.src = '';
                                    if (embedContainer) {
                                        embedContainer.style.display = 'none';
                                    }
                                    // Clear embed check interval if exists
                                    if (window.angleEmbedCheckInterval) {
                                        clearInterval(window.angleEmbedCheckInterval);
                                        window.angleEmbedCheckInterval = null;
                                    }
                                    // Remove message listener if exists
                                    if (window.angleEmbedMessageHandler) {
                                        window.removeEventListener('message', window.angleEmbedMessageHandler);
                                        window.angleEmbedMessageHandler = null;
                                    }
                                    isAngleSongPlaying = false;
                                    // Resume bg music
                                    if (bgMusic && isMusicPlaying) {
                                        bgMusic.volume = 0.3;
                                        bgMusic.play().catch(err => console.log('BG music resume error:', err));
                                    }
                                    // Hide chat
                                    if (chatEl) {
                                        chatEl.style.display = 'none';
                                    }
                                    char.isInteracting = false;
                                }

                                // Show container and overlay
                                if (embedContainer) {
                                    embedContainer.style.display = 'block';
                                    // Prevent clicks on container from closing (only overlay should close)
                                    embedContainer.onclick = (e) => {
                                        e.stopPropagation();
                                    };
                                }
                                // Update chat message
                                if (chatEl) {
                                    chatEl.textContent = "Playing song...";
                                }

                                // Add close button functionality
                                const closeBtn = document.getElementById('angle-song-close');
                                if (closeBtn) {
                                    // Remove any existing listeners
                                    closeBtn.onclick = null;
                                    closeBtn.addEventListener('click', closeEmbed);
                                }

                                // Listen for messages from embedded players (YouTube, Spotify, SoundCloud)
                                // This helps detect when user pauses or stops the player
                                function handleEmbedMessage(event) {
                                    // YouTube sends messages when player state changes
                                    if (event.data && typeof event.data === 'string') {
                                        try {
                                            const data = JSON.parse(event.data);
                                            // YouTube player events
                                            if (data.event === 'onStateChange') {
                                                // State 0 = ended, 2 = paused
                                                if (data.info === 0 || data.info === 2) {
                                                    // Song ended or paused - close embed after a short delay
                                                    setTimeout(() => {
                                                        if (isAngleSongPlaying) {
                                                            closeEmbed();
                                                        }
                                                    }, 2000); // Wait 2 seconds in case user resumes
                                                }
                                            }
                                        } catch (e) {
                                            // Not JSON, might be other message format
                                        }
                                    }
                                    // SoundCloud sends messages
                                    if (event.data && event.data.method === 'getCurrentSound') {
                                        // SoundCloud player events
                                    }
                                }

                                window.addEventListener('message', handleEmbedMessage);

                                // Store message handler to remove it later
                                window.angleEmbedMessageHandler = handleEmbedMessage;

                                // Try to detect when embed is paused/stopped
                                // For YouTube, Spotify, SoundCloud embeds, we'll check periodically
                                let embedCheckInterval = setInterval(() => {
                                    try {
                                        // Check if iframe is still visible and playing
                                        if (embedContainer && embedContainer.style.display === 'none') {
                                            clearInterval(embedCheckInterval);
                                            window.angleEmbedCheckInterval = null;
                                            return;
                                        }
                                        // Try to access iframe content (may fail due to CORS)
                                        // If we can't access it, we'll rely on user interaction and message events
                                    } catch (e) {
                                        // CORS restriction - can't access iframe content
                                        // This is expected, we'll rely on close button, Q key, and message events
                                    }
                                }, 1000);

                                // Store interval ID to clear it later
                                window.angleEmbedCheckInterval = embedCheckInterval;
                            } else {
                                // Direct audio file - use Audio element
                                angleSongPlayer = new Audio();
                                angleSongPlayer.volume = 0.7;
                                isAngleSongPlaying = true;

                                // Update chat message
                                if (chatEl) {
                                    chatEl.textContent = "Playing song...";
                                }

                                // Handle loading errors
                                angleSongPlayer.addEventListener('error', (e) => {
                                    console.log('Song load error:', e, angleSongPlayer.error);
                                    alert('Error loading song. Please check the URL is a valid direct audio file link (.mp3, .wav, .ogg)');
                                    isAngleSongPlaying = false;
                                    if (chatEl) {
                                        chatEl.style.display = 'none';
                                    }
                                    char.isInteracting = false;
                                    // Resume bg music on error
                                    if (bgMusic && isMusicPlaying) {
                                        bgMusic.volume = 0.3;
                                        bgMusic.play().catch(err => console.log('BG music resume error:', err));
                                    }
                                });

                                // Resume bg music when song ends
                                angleSongPlayer.addEventListener('ended', () => {
                                    isAngleSongPlaying = false;
                                    if (bgMusic && isMusicPlaying) {
                                        bgMusic.volume = 0.3;
                                        bgMusic.play().catch(e => console.log('BG music resume error:', e));
                                    }
                                    // Hide chat bubble
                                    if (chatEl) {
                                        chatEl.style.display = 'none';
                                    }
                                    char.isInteracting = false;
                                });

                                // Set source and load
                                angleSongPlayer.src = url;
                                angleSongPlayer.crossOrigin = 'anonymous'; // Allow CORS for external URLs
                                angleSongPlayer.load(); // Load the audio file

                                // Play the song after it's loaded
                                angleSongPlayer.addEventListener('canplaythrough', () => {
                                    angleSongPlayer.play().catch(e => {
                                        console.log('Song play error:', e);
                                        alert('Error playing song. Please check the URL is valid and accessible.');
                                        isAngleSongPlaying = false;
                                        if (chatEl) {
                                            chatEl.style.display = 'none';
                                        }
                                        char.isInteracting = false;
                                        // Resume bg music on error
                                        if (bgMusic && isMusicPlaying) {
                                            bgMusic.volume = 0.3;
                                            bgMusic.play().catch(err => console.log('BG music resume error:', err));
                                        }
                                    });
                                }, { once: true });

                                // Also try to play immediately (in case it's already loaded)
                                angleSongPlayer.play().catch(e => {
                                    // If it fails, wait for canplaythrough event
                                    console.log('Waiting for audio to load...');
                                });
                            }
                            } else {
                                // No URL provided, hide chat after 3 seconds
                                setTimeout(() => {
                                    if (chatEl) {
                                        chatEl.style.display = 'none';
                                    }
                                    char.isInteracting = false;
                                }, 3000);
                            }
                        });
                    }
                }
            }
        });
        window.addEventListener('keyup', e => {
            keys[e.key.toLowerCase()] = false;
            if (['j', 'k', 'l'].includes(e.key.toLowerCase())) setExpression('neutral');
        });

        // ── Mouse Camera Control Events ──────────────────────────────────────────────
        const canvasContainer = document.getElementById('canvas-container');
        
        // Optimize cursor changes with CSS class
        if (canvasContainer) {
            canvasContainer.classList.add('grab-cursor');
        }

        // Throttle mousemove using requestAnimationFrame for better INP
        let rafId = null;
        let pendingMouseMove = null;

        window.addEventListener('mousedown', (e) => {
            isMouseDown = true;
            mouseX = e.clientX;
            mouseY = e.clientY;
            if (canvasContainer) {
                canvasContainer.classList.remove('grab-cursor');
                canvasContainer.classList.add('grabbing-cursor');
            }
            // Prevent default to avoid text selection
            e.preventDefault();
        }, { passive: false });

        window.addEventListener('mousemove', (e) => {
            if (isMouseDown) {
                // Store the latest mouse position
                pendingMouseMove = { clientX: e.clientX, clientY: e.clientY };
                
                // Throttle using requestAnimationFrame
                if (rafId === null) {
                    rafId = requestAnimationFrame(() => {
                        if (pendingMouseMove && isMouseDown) {
                            const deltaX = pendingMouseMove.clientX - mouseX;
                            const deltaY = pendingMouseMove.clientY - mouseY;

                            // Update camera rotation
                            cameraRotationY -= deltaX * MOUSE_SENSITIVITY;
                            cameraRotationX -= deltaY * MOUSE_SENSITIVITY;

                            // Clamp vertical rotation
                            cameraRotationX = Math.max(MIN_PITCH, Math.min(MAX_PITCH, cameraRotationX));

                            mouseX = pendingMouseMove.clientX;
                            mouseY = pendingMouseMove.clientY;
                        }
                        rafId = null;
                        pendingMouseMove = null;
                    });
                }
            }
        }, { passive: true });

        window.addEventListener('mouseup', () => {
            isMouseDown = false;
            if (rafId !== null) {
                cancelAnimationFrame(rafId);
                rafId = null;
            }
            pendingMouseMove = null;
            if (canvasContainer) {
                canvasContainer.classList.remove('grabbing-cursor');
                canvasContainer.classList.add('grab-cursor');
            }
        });

        // Also handle mouse leave to stop dragging
        window.addEventListener('mouseleave', () => {
            isMouseDown = false;
            if (rafId !== null) {
                cancelAnimationFrame(rafId);
                rafId = null;
            }
            pendingMouseMove = null;
            if (canvasContainer) {
                canvasContainer.classList.remove('grabbing-cursor');
                canvasContainer.classList.add('grab-cursor');
            }
        });

        // ── Physics state ─────────────────────────────────────────────────────────────
        const ghostVel = new THREE.Vector3(), duckVel = new THREE.Vector3();
        const SPEED = 30, GRAVITY = 30, JUMP = 15;
        const SPEED2 = 15; // For duck, slower than ghost
        let ghostCanJump = true;
        const defScale = new THREE.Vector3(1, 1, 1), tgtScale = new THREE.Vector3(1, 1, 1);
        const camOffset = new THREE.Vector3(0, 6, 16), camTarget = new THREE.Vector3();
        const clock = new THREE.Clock();
        let isHugging = false;
        let neckStretch = 1.0;
        let lastDuckWalkTime = 0;
        let lastWindStreamTime = 0;

        // ── Mouse Camera Control ─────────────────────────────────────────────────────
        let isMouseDown = false;
        let mouseX = 0;
        let mouseY = 0;
        let cameraRotationY = 0; // Horizontal rotation (around Y axis)
        let cameraRotationX = 0; // Vertical rotation (pitch)
        const MOUSE_SENSITIVITY = 0.004; // Increased for faster camera rotation
        const MIN_PITCH = -Math.PI / 3; // Limit vertical rotation
        const MAX_PITCH = Math.PI / 3;

        function lerpAngle(a, b, t) { let d = b - a; while (d < -Math.PI) d += Math.PI * 2; while (d > Math.PI) d -= Math.PI * 2; return a + d * t; }

        // ── Main loop ─────────────────────────────────────────────────────────────────
        let terrainUpdateFrame = 0; // Frame counter for terrain updates
        function animate() {
            requestAnimationFrame(animate);
            const delta = Math.min(clock.getDelta(), 0.1);
            const time = clock.getElapsedTime();

            // Keep background music playing if it should be (but not while ang.mp3 or custom song is playing)
            if (isMusicPlaying && bgMusic.paused && !isAngleSoundPlaying && !isAngleSongPlaying) {
                bgMusic.volume = 0.3; // Restore volume
                bgMusic.play().catch(e => console.log('BG music play error:', e));
            }

            // Optimize terrain updates: only update every other frame to reduce main thread blocking
            terrainUpdateFrame++;
            if (terrainUpdateFrame % 2 === 0) {
                const posAttr = floorGeo.attributes.position;
                for (let i = 0; i < posAttr.count; i++) posAttr.setZ(i, getTerrainY(posAttr.getX(i), posAttr.getY(i), time));
                floorGeo.computeVertexNormals(); 
                posAttr.needsUpdate = true;
            }

            const camAngle = Math.atan2(camera.position.x - ghostGroup.position.x, camera.position.z - ghostGroup.position.z);

            // ── DUCK ──────────────────────────────────────────────────────────────────
            const dDir = new THREE.Vector3();
            if (keys['arrowup']) dDir.z -= 1;
            if (keys['arrowdown']) dDir.z += 1;
            if (keys['arrowleft']) dDir.x -= 1;
            if (keys['arrowright']) dDir.x += 1;
            dDir.normalize();

            if (dDir.lengthSq() > 0) {
                const mx = dDir.x * Math.cos(camAngle) + dDir.z * Math.sin(camAngle);
                const mz = -dDir.x * Math.sin(camAngle) + dDir.z * Math.cos(camAngle);
                duckVel.x = mx * SPEED2; duckVel.z = mz * SPEED2;
                duckGroup.rotation.y = lerpAngle(duckGroup.rotation.y, Math.atan2(duckVel.x, duckVel.z), 10 * delta);
                bodyGroup.rotation.z = Math.sin(time * 15) * 0.1;
                leftLeg.rotation.x = Math.max(0, Math.sin(time * 15)) * 0.3;
                rightLeg.rotation.x = Math.max(0, Math.sin(time * 15 + Math.PI)) * 0.3;
                if (time - lastDuckWalkTime > 0.35) {
                    playDuckWalkSound();
                    lastDuckWalkTime = time;
                }
            } else {
                duckVel.x *= (1 - 10 * delta); duckVel.z *= (1 - 10 * delta);
                bodyGroup.rotation.z = 0;
                leftLeg.rotation.x = 0;
                rightLeg.rotation.x = 0;
            }
            duckGroup.position.x += duckVel.x * delta;
            duckGroup.position.z += duckVel.z * delta;

            // Duck position on terrain - move up a little on Y axis
            duckGroup.position.y = getTerrainY(duckGroup.position.x, duckGroup.position.z, time) + 1.2;

            // Enter = neck stretch (scale only, don't move position)
            neckStretch = THREE.MathUtils.lerp(neckStretch, keys['enter'] ? 4.5 : 1.0, 8 * delta);
            neckGroup.scale.y = neckStretch;

            // Neck base position in world space (updated AFTER duck moves)
            const neckBaseWorld = new THREE.Vector3();
            bodyGroup.getWorldPosition(neckBaseWorld);
            neckBaseWorld.y += 2.0;

            // ── GHOST ─────────────────────────────────────────────────────────────────
            const gDir = new THREE.Vector3();
            if (keys['w']) gDir.z -= 1; if (keys['s']) gDir.z += 1;
            if (keys['a']) gDir.x -= 1; if (keys['d']) gDir.x += 1;
            gDir.normalize();
            const gMoving = gDir.lengthSq() > 0;

            // Spawn flower particles when moving
            if (gMoving) {
                const moveVel = gDir.clone().multiplyScalar(SPEED);

                for (let p = 0; p < 2; p++) {
                    const randomVel = new THREE.Vector3(
                        (Math.random() - 0.5) * 8,
                        (Math.random() - 0.5) * 4 + 2,
                        (Math.random() - 0.5) * 8
                    );
                    const spawnPos = ghostGroup.position.clone().add(
                        new THREE.Vector3(
                            (Math.random() - 0.5) * 2,
                            (Math.random() - 0.5) * 2,
                            (Math.random() - 0.5) * 2
                        )
                    );
                    const finalVel = moveVel.clone().multiplyScalar(0.2).add(randomVel);
                    spawnFlowerParticle(spawnPos, finalVel, 1.0 + Math.random() * 0.5);
                }
            }
            const dist = ghostGroup.position.distanceTo(duckGroup.position);
            isHugging = dist < 5.0 && !gMoving;

            if (isHugging) {
                // Ghost stays still on ground, arms out
                const gy = getTerrainY(ghostGroup.position.x, ghostGroup.position.z, time) + bottomOffset;
                ghostGroup.position.y = THREE.MathUtils.lerp(ghostGroup.position.y, gy, 10 * delta);
                ghostVel.set(0, 0, 0); ghostCanJump = true;
                ghostBody.position.y = bottomOffset;
                ghostBody.scale.lerp(defScale, 10 * delta);
                leftArm.rotation.z = -Math.PI / 2;
                rightArm.rotation.z = Math.PI / 2;
            } else {
                if (gMoving) {
                    const mx = gDir.x * Math.cos(camAngle) + gDir.z * Math.sin(camAngle);
                    const mz = -gDir.x * Math.sin(camAngle) + gDir.z * Math.cos(camAngle);
                    ghostVel.x = mx * SPEED; ghostVel.z = mz * SPEED;
                    ghostGroup.rotation.y = lerpAngle(ghostGroup.rotation.y, Math.atan2(ghostVel.x, ghostVel.z), 10 * delta);

                    // Spawn wind streams now using actual velocity direction
                    if (time - lastWindStreamTime > 0.2) {
                        const actualMoveDir = new THREE.Vector3(ghostVel.x, 0, ghostVel.z).normalize();
                        const rightDir = new THREE.Vector3(-actualMoveDir.z, 0, actualMoveDir.x).normalize();
                        const upDir = new THREE.Vector3(0, 1, 0);
                        const windParallelDir = actualMoveDir.clone().multiplyScalar(-1).normalize();

                        // Front center wind
                        const posCenter = ghostGroup.position.clone().add(actualMoveDir.clone().multiplyScalar(5)).add(
                            new THREE.Vector3((Math.random() - 0.5) * 0.3, (Math.random() - 0.5) * 1.2, (Math.random() - 0.5) * 0.3)
                        );
                        spawnWindStream(posCenter, windParallelDir, SPEED * 1.5, 0.1);

                        // Left side wind
                        const pos1 = ghostGroup.position.clone().add(rightDir.clone().multiplyScalar(-8)).add(
                            new THREE.Vector3((Math.random() - 0.5) * 0.3, (Math.random() - 0.5) * 1.2, (Math.random() - 0.5) * 0.3)
                        );
                        spawnWindStream(pos1, windParallelDir, SPEED * 1.5, 0.1);

                        // Right side wind
                        const pos2 = ghostGroup.position.clone().add(rightDir.clone().multiplyScalar(8)).add(
                            new THREE.Vector3((Math.random() - 0.5) * 0.3, (Math.random() - 0.5) * 1.2, (Math.random() - 0.5) * 0.3)
                        );
                        spawnWindStream(pos2, windParallelDir, SPEED * 1.5, 0.1);

                        // Top wind
                        const pos3 = ghostGroup.position.clone().add(upDir.clone().multiplyScalar(7)).add(
                            new THREE.Vector3((Math.random() - 0.5) * 0.5, (Math.random() - 0.5) * 0.3, (Math.random() - 0.5) * 0.5)
                        );
                        spawnWindStream(pos3, windParallelDir, SPEED * 1.5, 0.1);

                        // Top-left wind
                        const pos4 = ghostGroup.position.clone().add(upDir.clone().multiplyScalar(7)).add(rightDir.clone().multiplyScalar(-6)).add(
                            new THREE.Vector3((Math.random() - 0.5) * 0.3, (Math.random() - 0.5) * 0.3, (Math.random() - 0.5) * 0.3)
                        );
                        spawnWindStream(pos4, windParallelDir, SPEED * 1.5, 0.1);

                        // Top-right wind
                        const pos5 = ghostGroup.position.clone().add(upDir.clone().multiplyScalar(7)).add(rightDir.clone().multiplyScalar(6)).add(
                            new THREE.Vector3((Math.random() - 0.5) * 0.3, (Math.random() - 0.5) * 0.3, (Math.random() - 0.5) * 0.3)
                        );
                        spawnWindStream(pos5, windParallelDir, SPEED * 1.5, 0.1);

                        lastWindStreamTime = time;
                    }
                } else {
                    ghostVel.x *= (1 - 10 * delta); ghostVel.z *= (1 - 10 * delta);
                }
                if (keys[' '] && ghostCanJump) {
                    ghostVel.y = JUMP;
                    ghostCanJump = false;
                    tgtScale.set(0.6, 1.4, 0.6);
                    playJumpSound();
                }
                ghostVel.y -= GRAVITY * delta;
                ghostGroup.position.addScaledVector(ghostVel, delta);
                const fy = getTerrainY(ghostGroup.position.x, ghostGroup.position.z, time);
                if (ghostGroup.position.y <= fy + bottomOffset) {
                    ghostGroup.position.y = fy + bottomOffset;
                    ghostVel.y = 0;
                    if (!ghostCanJump) tgtScale.set(1.5, 0.6, 1.5);
                    ghostCanJump = true;
                }
                ghostBody.scale.lerp(tgtScale, 15 * delta);
                tgtScale.lerp(defScale, 5 * delta);

                // Lean forward when moving
                const targetLean = gMoving ? THREE.MathUtils.degToRad(20) : 0;
                ghostBody.rotation.x = THREE.MathUtils.lerp(ghostBody.rotation.x, targetLean, 8 * delta);

                ghostBody.position.y = bottomOffset + (ghostCanJump ? Math.sin(time * 2) * 0.3 : 0);

                // Running arm animation - arms swing forward and backward
                if (gMoving) {
                    const runSpeed = 8; // Faster animation when running
                    const armSwing = Math.sin(time * runSpeed) * 0.6; // Forward/backward swing amplitude

                    // Left arm swings forward and backward (opposite phase to right)
                    leftArm.rotation.x = Math.PI / 4 + armSwing; // Forward/backward motion
                    leftArm.rotation.z = -Math.PI / 6; // Keep side angle

                    // Right arm swings opposite phase (when left is forward, right is back)
                    rightArm.rotation.x = Math.PI / 4 - armSwing; // Opposite phase
                    rightArm.rotation.z = Math.PI / 6; // Keep side angle
                } else {
                    // Idle animation - gentle sway
                    leftArm.rotation.x = Math.PI / 4;
                    rightArm.rotation.x = Math.PI / 4;
                    leftArm.rotation.z = -Math.PI / 6 + Math.sin(time * 2) * 0.1;
                    rightArm.rotation.z = Math.PI / 6 - Math.sin(time * 2) * 0.1;
                }
            }

            // Tears
            if (currentExpression === 'crying') {
                tears.forEach(t => {
                    t.yOffset += delta * 2; if (t.yOffset > 1.0) t.yOffset = 0;
                    t.mesh.position.set(t.isLeft ? -0.4 : 0.4, 0.1 - t.yOffset, 0.1);
                    t.mesh.scale.setScalar(1.0 - t.yOffset);
                });
            }

            // ── SIMPLE HUG INTERACTION ────────────────────────────────────────────────
            const up3 = new THREE.Vector3(0, 1, 0);

            if (isHugging) {
                // Ghost body center in world
                const gc = ghostGroup.position.clone();
                gc.y += 2.0; // mid-ghost height

                const toGN = new THREE.Vector3().subVectors(gc, neckBaseWorld).normalize();
                const right3 = new THREE.Vector3().crossVectors(up3, toGN);
                if (right3.lengthSq() < 0.001) right3.set(1, 0, 0); else right3.normalize();
                const wr = 1.4;

                // 7 world-space target control points forming a wrap path
                const targets = [
                    neckBaseWorld.clone(),
                    neckBaseWorld.clone().lerp(gc, 0.25).addScaledVector(up3, 1.8),
                    neckBaseWorld.clone().lerp(gc, 0.55).addScaledVector(up3, 0.4),
                    gc.clone().addScaledVector(right3, wr),
                    gc.clone().addScaledVector(toGN, wr),
                    gc.clone().addScaledVector(right3, -wr),
                    gc.clone().addScaledVector(toGN, -wr * 0.7).addScaledVector(up3, 1.0)
                ];

                // Lerp each CP toward its target
                const NECK_SPEED = 10;
                for (let i = 0; i < NUM_CP; i++) neckCP[i].lerp(targets[i], NECK_SPEED * delta);

                // Rebuild tube
                rebuildTube(neckCP);

                // Show floating head at end CP, oriented along last segment
                floatingHead.visible = true;
                neckGroup.visible = false;

                floatingHead.position.copy(neckCP[NUM_CP - 1]);
                const lastDir = new THREE.Vector3().subVectors(neckCP[NUM_CP - 1], neckCP[NUM_CP - 2]);
                if (lastDir.lengthSq() > 0.001) {
                    const mat4 = new THREE.Matrix4().lookAt(new THREE.Vector3(), lastDir.normalize(), up3);
                    floatingHead.quaternion.setFromRotationMatrix(mat4);
                }

            } else {
                // All CPs retract back to neck base
                for (let i = 0; i < NUM_CP; i++) neckCP[i].lerp(neckBaseWorld, 14 * delta);

                floatingHead.visible = false;
                neckGroup.visible = true;

                // Show tube while retracting, hide once collapsed
                const spread = neckCP[NUM_CP - 1].distanceTo(neckBaseWorld);
                if (spread > 0.4) {
                    rebuildTube(neckCP);
                } else {
                    if (tubeMesh) { scene.remove(tubeMesh); tubeMesh.geometry.dispose(); tubeMesh = null; }
                }
            }

            // ── Particles ─────────────────────────────────────────────────────────────
            const pa = particles.geometry.attributes.position.array;
            for (let i = 0; i < pCount; i++) {
                pa[i * 3] += pVel[i].x; pa[i * 3 + 1] += pVel[i].y; pa[i * 3 + 2] += pVel[i].z;
                if (pa[i * 3 + 1] > 100) pa[i * 3 + 1] = 0; if (pa[i * 3 + 1] < 0) pa[i * 3 + 1] = 100;
                if (pa[i * 3] > 300) pa[i * 3] = -300; if (pa[i * 3] < -300) pa[i * 3] = 300;
                if (pa[i * 3 + 2] > 300) pa[i * 3 + 2] = -300; if (pa[i * 3 + 2] < -300) pa[i * 3 + 2] = 300;
            }
            particles.geometry.attributes.position.needsUpdate = true;

            // ── Update Flower Particles ──────────────────────────────────────────────
            for (let i = 0; i < flowerParticleCount; i++) {
                const flower = flowerMeshes[i];
                flower.life += delta / flower.maxLife;

                if (flower.life < 1.0) {
                    // Update position
                    flower.mesh.position.x += flower.velocity.x * delta;
                    flower.mesh.position.y += flower.velocity.y * delta;
                    flower.mesh.position.z += flower.velocity.z * delta;

                    // Apply gravity and drag
                    flower.velocity.y -= 6 * delta;
                    flower.velocity.x *= (1 - delta * 0.4);
                    flower.velocity.z *= (1 - delta * 0.4);

                    // Rotate flower
                    flower.mesh.rotation.x += delta * 2;
                    flower.mesh.rotation.y += delta * 3;

                    // Fade out and shrink
                    const fadeAlpha = 1.0 - flower.life;
                    flower.mesh.material.opacity = 0.8 * fadeAlpha;
                    flower.mesh.material.emissiveIntensity = 0.5 * fadeAlpha;
                    flower.mesh.scale.setScalar(fadeAlpha);
                } else {
                    flower.mesh.visible = false;
                }
            }

            // ── Update Wind Stream Particles ──────────────────────────────────────────
            for (let i = 0; i < windStreamCount; i++) {
                windStreamLife[i] += delta / windStreamMaxLife[i];

                if (windStreamLife[i] < 1.0) {
                    // Start point moves along direction
                    const moveX = windStreamVel[i].dirX * delta * 12;
                    const moveY = windStreamVel[i].dirY * delta * 12;
                    const moveZ = windStreamVel[i].dirZ * delta * 12;

                    windStreamPos[i * 6] += moveX;
                    windStreamPos[i * 6 + 1] += moveY;
                    windStreamPos[i * 6 + 2] += moveZ;

                    // End point (maintains trail length)
                    windStreamPos[i * 6 + 3] = windStreamPos[i * 6] + windStreamVel[i].dirX * windStreamVel[i].trailLen * 0.15;
                    windStreamPos[i * 6 + 4] = windStreamPos[i * 6 + 1] + windStreamVel[i].dirY * windStreamVel[i].trailLen * 0.15;
                    windStreamPos[i * 6 + 5] = windStreamPos[i * 6 + 2] + windStreamVel[i].dirZ * windStreamVel[i].trailLen * 0.15;
                } else {
                    // Hide dead particles by collapsing to same point
                    windStreamPos[i * 6] = 0;
                    windStreamPos[i * 6 + 1] = 0;
                    windStreamPos[i * 6 + 2] = 0;
                    windStreamPos[i * 6 + 3] = 0;
                    windStreamPos[i * 6 + 4] = 0;
                    windStreamPos[i * 6 + 5] = 0;
                }
            }
            windStreamParticles.geometry.attributes.position.needsUpdate = true;

            // ── Pinwheel Animation ────────────────────────────────────────────────────
            const pwDummy = new THREE.Object3D();
            const pwBladeDummy = new THREE.Object3D();

            for (let i = 0; i < pinwheelCount; i++) {
                // Calculate slow floating position
                const x = pinwheelPositions[i * 3] + Math.sin(time * 0.2 + pinwheelPhases[i]) * 2;
                const y = pinwheelPositions[i * 3 + 1] + Math.sin(time * pinwheelSpeeds[i] + pinwheelPhases[i]) * 1.5;
                const z = pinwheelPositions[i * 3 + 2] + Math.cos(time * 0.2 + pinwheelPhases[i]) * 2;

                pwDummy.position.set(x, y, z);
                pwDummy.rotation.set(pinwheelOrientations[i * 3], pinwheelOrientations[i * 3 + 1], pinwheelOrientations[i * 3 + 2]);
                pwDummy.updateMatrix();

                // Update hub position
                pinwheelHubs.setMatrixAt(i, pwDummy.matrix);

                const spin = time * pinwheelSpinSpeeds[i];

                // Update the 4 wings for this pinwheel
                for (let j = 0; j < 4; j++) {
                    pwBladeDummy.copy(pwDummy);
                    pwBladeDummy.rotateZ(spin + (j * Math.PI / 2));
                    pwBladeDummy.updateMatrix();
                    pinwheelBlades[j].setMatrixAt(i, pwBladeDummy.matrix);
                }
            }

            pinwheelHubs.instanceMatrix.needsUpdate = true;
            for (let j = 0; j < 4; j++) {
                pinwheelBlades[j].instanceMatrix.needsUpdate = true;
            }

            // ── Camera ────────────────────────────────────────────────────────────────
            // Apply mouse rotation to camera offset
            const rotatedOffset = camOffset.clone();

            // Apply horizontal rotation (Y axis)
            rotatedOffset.applyAxisAngle(new THREE.Vector3(0, 1, 0), cameraRotationY);

            // Apply vertical rotation (X axis) - rotate around a perpendicular axis
            const rightVector = new THREE.Vector3(1, 0, 0);
            rightVector.applyAxisAngle(new THREE.Vector3(0, 1, 0), cameraRotationY);
            rotatedOffset.applyAxisAngle(rightVector, cameraRotationX);

            // Also apply slight rotation based on ghost movement
            rotatedOffset.applyAxisAngle(new THREE.Vector3(0, 1, 0), ghostGroup.rotation.y * 0.1);

            // Position camera
            camera.position.lerp(ghostGroup.position.clone().add(rotatedOffset), 5 * delta);
            camTarget.copy(ghostGroup.position).add(new THREE.Vector3(0, 2, 0));
            camera.lookAt(camTarget);
            pinkLight.position.set(ghostGroup.position.x - 3, ghostGroup.position.y + 3, ghostGroup.position.z + 3);
            blueLight.position.set(ghostGroup.position.x + 3, ghostGroup.position.y + 3, ghostGroup.position.z - 3);

            // ── Character Interaction ─────────────────────────────────────────────────
            // Function to get character ID from index (maps to GLB file names)
            function getCharId(index) {
                const charMap = {
                    0: 'char1',
                    1: 'char2',
                    2: 'char3',
                    3: 'f',
                    5: 'angle',
                    6: 've',
                    7: 'pp',
                    8: 'lm',
                    9: 'fat',
                    10: 'lotus',
                    11: 'daisy',
                    12: 'lotus2',
                    13: 'threlef',
                    14: 'pinkf',
                    15: 'lotus3'
                };
                return charMap[index] || `char${index + 1}`;
            }

            closestCharIndex = -1;
            let minDistance = INTERACTION_DISTANCE;

            for (let i = 0; i < characterModels.length; i++) {
                const char = characterModels[i];
                if (!char || !char.group) continue;

                // Get character world position
                const charPos = new THREE.Vector3();
                char.group.getWorldPosition(charPos);

                // Calculate distance from ghost
                const distance = ghostGroup.position.distanceTo(charPos);

                // Get notification and chat elements
                const charId = getCharId(i);
                const notifEl = document.getElementById(`${charId}-notif`);
                const chatEl = document.getElementById(`${charId}-chat`);

                // Position notification above character head (3D to 2D projection)
                const headPos = charPos.clone();
                headPos.y += 3; // Above head

                const screenPos = headPos.clone().project(camera);
                const x = (screenPos.x * 0.5 + 0.5) * window.innerWidth;
                const y = (-screenPos.y * 0.5 + 0.5) * window.innerHeight;

                if (distance < INTERACTION_DISTANCE) {
                    // Character is close enough
                    if (distance < minDistance) {
                        minDistance = distance;
                        closestCharIndex = i;
                    }

                    // Show notification if not interacting (exclude lm.glb and fat.glb - handled separately)
                    if (!char.isInteracting && notifEl && i !== 8 && i !== 9) {
                        // Check if character is on screen
                        if (screenPos.x >= -1 && screenPos.x <= 1 &&
                            screenPos.y >= -1 && screenPos.y <= 1 &&
                            screenPos.z < 1 && screenPos.z > -1) {
                            notifEl.style.display = 'block';
                            notifEl.style.left = x + 'px';
                            // Separate y-axis positioning: some characters need higher offset
                            if (i === 3 || i === 5 || i === 6 || i === 7) {
                                // f.glb (3), angle.glb (5), ve.glb (6), pp.glb (7) - position higher above head
                                notifEl.style.top = (y - 180) + 'px';
                            } else {
                                // Pink characters (0, 1, 2) - standard position
                                notifEl.style.top = (y - 40) + 'px';
                            }
                            notifEl.style.transform = 'translateX(-50%)';
                        } else {
                            notifEl.style.display = 'none';
                        }
                    }

                    // Show Q notification for angle.glb (index 5) if not interacting
                    if (i === 5 && !char.isInteracting) {
                        const qNotifEl = document.getElementById('angle-q-notif');
                        if (qNotifEl) {
                            // Check if character is on screen
                            if (screenPos.x >= -1 && screenPos.x <= 1 &&
                                screenPos.y >= -1 && screenPos.y <= 1 &&
                                screenPos.z < 1 && screenPos.z > -1) {
                                qNotifEl.style.display = 'block';
                                qNotifEl.style.left = (x + 60) + 'px'; // Position right next to F notification
                                // Match F notification Y position for angle.glb (y - 180)
                                qNotifEl.style.top = (y - 180) + 'px';
                                qNotifEl.style.transform = 'translateX(-50%)';
                            } else {
                                qNotifEl.style.display = 'none';
                            }
                        }
                    } else {
                        // Hide Q notification for other characters or when interacting
                        const qNotifEl = document.getElementById('angle-q-notif');
                        if (qNotifEl) {
                            qNotifEl.style.display = 'none';
                        }
                    }

                    // Position and show chat bubble if interacting (exclude lm.glb and fat.glb - handled separately)
                    if (char.isInteracting && chatEl && i !== 8 && i !== 9) {
                        chatEl.style.display = 'block';
                        chatEl.style.left = x + 'px';
                        // Separate y-axis positioning: characters 6-10 (indices 5-9) use higher offset
                        if (i == 3 || i === 5 || i === 6 || i === 7) {
                            // angle.glb (5), ve.glb (6), pp.glb (7) - position higher above head
                            chatEl.style.top = (y - 160) + 'px';
                        } else {
                            // Pink characters (0, 1, 2) and f.glb (3) - standard position
                            chatEl.style.top = (y - 60) + 'px';
                        }
                        chatEl.style.transform = 'translateX(-50%)';
                    }
                } else {
                    // Character is too far - hide everything and reset interaction
                    if (notifEl) notifEl.style.display = 'none';
                    if (chatEl) {
                        chatEl.style.display = 'none';
                    }
                    // Hide Q notification for angle.glb when too far
                    if (i === 5) {
                        const qNotifEl = document.getElementById('angle-q-notif');
                        if (qNotifEl) {
                            qNotifEl.style.display = 'none';
                        }
                    }
                    // Reset interaction state when player moves away
                    if (char.isInteracting) {
                        char.isInteracting = false;
                        // Clear timeout if player moves away
                        if (characterTimeouts[i]) {
                            clearTimeout(characterTimeouts[i]);
                            characterTimeouts[i] = null;
                        }
                        // Stop song if it's angle.glb and song is playing
                        if (i === 5 && isAngleSongPlaying) {
                            const embedIframe = document.getElementById('angle-song-embed');
                            const embedContainer = document.getElementById('angle-song-embed-container');
                            if (angleSongPlayer) {
                                angleSongPlayer.pause();
                                angleSongPlayer = null;
                            }
                            if (embedIframe) {
                                embedIframe.src = '';
                            }
                            if (embedContainer) {
                                embedContainer.style.display = 'none';
                            }
                            // Clear embed check interval if exists
                            if (window.angleEmbedCheckInterval) {
                                clearInterval(window.angleEmbedCheckInterval);
                                window.angleEmbedCheckInterval = null;
                            }
                            // Remove message listener if exists
                            if (window.angleEmbedMessageHandler) {
                                window.removeEventListener('message', window.angleEmbedMessageHandler);
                                window.angleEmbedMessageHandler = null;
                            }
                            isAngleSongPlaying = false;
                            // Resume bg music
                            if (bgMusic && isMusicPlaying) {
                                bgMusic.volume = 0.3;
                                bgMusic.play().catch(err => console.log('BG music resume error:', err));
                            }
                        }
                    }
                }
            }

            // Hide notifications and chat bubbles for characters that are not closest
            for (let i = 0; i < characterModels.length; i++) {
                if (i !== closestCharIndex) {
                    const char = characterModels[i];
                    if (char) {
                        const notifEl = document.getElementById(`char${i + 1}-notif`);
                        const chatEl = document.getElementById(`char${i + 1}-chat`);
                        if (notifEl) notifEl.style.display = 'none';
                        if (chatEl) chatEl.style.display = 'none';
                        // Hide Q notification for angle.glb when not closest
                        if (i === 5) {
                            const qNotifEl = document.getElementById('angle-q-notif');
                            if (qNotifEl) {
                                qNotifEl.style.display = 'none';
                            }
                        }
                        // Reset interaction state for non-closest characters
                        if (char.isInteracting) {
                            char.isInteracting = false;
                            if (characterTimeouts[i]) {
                                clearTimeout(characterTimeouts[i]);
                                characterTimeouts[i] = null;
                            }
                        }
                    }
                }
            }

            // ── New Character Interaction ──────────────────────────────────────────────
            isNewCharClose = false;
            if (newCharacterGroup && closestCharIndex < 0) {
                const charPos = new THREE.Vector3();
                newCharacterGroup.getWorldPosition(charPos);
                const distanceToGhost = ghostGroup.position.distanceTo(charPos);

                if (distanceToGhost < INTERACTION_DISTANCE) {
                    isNewCharClose = true;

                    // Show notification
                    const notifEl = document.getElementById('newchar-notif');
                    if (notifEl) {
                        // Position notification above character head (3D to 2D projection)
                        const headPos = charPos.clone();
                        headPos.y += 3;
                        const screenPos = headPos.clone().project(camera);

                        if (screenPos.x >= -1 && screenPos.x <= 1 &&
                            screenPos.y >= -1 && screenPos.y <= 1 &&
                            screenPos.z < 1 && screenPos.z > -1) {
                            const x = (screenPos.x * 0.5 + 0.5) * window.innerWidth;
                            const y = (-screenPos.y * 0.5 + 0.5) * window.innerHeight;

                            // Position notification above chat bubble (chat is at y - 60, so notification at y - 100)
                            notifEl.style.left = x + 'px';
                            notifEl.style.top = (y - 100) + 'px';
                            notifEl.style.transform = 'translateX(-50%)';
                            notifEl.style.display = 'block';
                        } else {
                            notifEl.style.display = 'none';
                        }
                    }
                } else {
                    // Hide notification when too far
                    const notifEl = document.getElementById('newchar-notif');
                    if (notifEl) {
                        notifEl.style.display = 'none';
                    }
                }
            } else {
                // Hide notification if pink character is closer
                const notifEl = document.getElementById('newchar-notif');
                if (notifEl) {
                    notifEl.style.display = 'none';
                }
            }

            // ── New Character Chat (Auto-rotating messages) ──────────────────────────
            if (newCharacterGroup) {
                const chatEl = document.getElementById('newchar-chat');
                if (chatEl) {
                    // Position chat bubble above character head (3D to 2D projection)
                    const charPos = new THREE.Vector3();
                    newCharacterGroup.getWorldPosition(charPos);
                    const headPos = charPos.clone();
                    headPos.y += 3; // Above head

                    // Check distance from ghost
                    const distanceToGhost = ghostGroup.position.distanceTo(charPos);
                    const maxDistance = 50; // Maximum distance to show chat (only when close)

                    // Project to screen space
                    const screenPos = headPos.clone().project(camera);
                    const ghostScreenPos = ghostGroup.position.clone().project(camera);
                    const ghostHeadPos = ghostGroup.position.clone();
                    ghostHeadPos.y += 2; // Ghost head position
                    const ghostHeadScreenPos = ghostHeadPos.clone().project(camera);

                    // Check if on screen
                    const isOnScreen = screenPos.x >= -1 && screenPos.x <= 1 &&
                        screenPos.y >= -1 && screenPos.y <= 1 &&
                        screenPos.z < 1 && screenPos.z > -1;

                    // Calculate screen positions in pixels
                    const charScreenX = (screenPos.x * 0.5 + 0.5) * window.innerWidth;
                    const charScreenY = (-screenPos.y * 0.5 + 0.5) * window.innerHeight;
                    const ghostScreenX = (ghostScreenPos.x * 0.5 + 0.5) * window.innerWidth;
                    const ghostScreenY = (-ghostScreenPos.y * 0.5 + 0.5) * window.innerHeight;
                    const ghostHeadScreenX = (ghostHeadScreenPos.x * 0.5 + 0.5) * window.innerWidth;
                    const ghostHeadScreenY = (-ghostHeadScreenPos.y * 0.5 + 0.5) * window.innerHeight;

                    // Chat bubble position (above character head)
                    const chatX = charScreenX;
                    const chatY = charScreenY - 60;

                    // Check if chat bubble overlaps with ghost (check both ghost body and head positions)
                    const chatWidth = 250; // max-width of chat
                    const chatHeight = 50; // approximate chat height
                    const chatLeft = chatX - chatWidth / 2;
                    const chatRight = chatX + chatWidth / 2;
                    const chatTop = chatY - chatHeight / 2;
                    const chatBottom = chatY + chatHeight / 2;

                    // Ghost bounding box (approximate)
                    const ghostSize = 80; // approximate ghost size in pixels
                    const ghostLeft = ghostHeadScreenX - ghostSize;
                    const ghostRight = ghostHeadScreenX + ghostSize;
                    const ghostTop = ghostHeadScreenY - ghostSize;
                    const ghostBottom = ghostHeadScreenY + ghostSize;

                    // Check if chat bubble overlaps with ghost
                    const isOverlapping = !(chatRight < ghostLeft || chatLeft > ghostRight ||
                        chatBottom < ghostTop || chatTop > ghostBottom);

                    // Check if ghost is between camera and character (would cause overlay)
                    const cameraToChar = new THREE.Vector3().subVectors(headPos, camera.position);
                    const cameraToGhost = new THREE.Vector3().subVectors(ghostGroup.position, camera.position);
                    const charDistance = cameraToChar.length();
                    const ghostDistance = cameraToGhost.length();

                    // Ghost is blocking if it's closer to camera AND overlapping on screen
                    const ghostIsBlocking = ghostDistance < charDistance && isOverlapping;

                    // Only show if:
                    // 1. Ghost is within distance range (close enough, no minimum - show even when next to character)
                    // 2. Character is on screen
                    // 3. Ghost is not blocking the character (ghost not in front AND not overlapping)
                    if (isOnScreen &&
                        distanceToGhost <= maxDistance &&
                        !ghostIsBlocking) {

                        // Update message every 3 seconds (only when visible)
                        if (time - lastMessageChangeTime >= 3) {
                            currentMessageIndex = (currentMessageIndex + 1) % newCharMessages.length;
                            chatEl.textContent = newCharMessages[currentMessageIndex];
                            lastMessageChangeTime = time;
                        }

                        chatEl.style.left = chatX + 'px';
                        chatEl.style.top = chatY + 'px';
                        chatEl.style.transform = 'translateX(-50%)';
                        chatEl.style.display = 'block';
                    } else {
                        chatEl.style.display = 'none';
                    }
                }
            }

            // ── Fat Character Chat (Auto-rotating messages) ──────────────────────────
            if (characterModels[9] && characterModels[9].group) {
                const fatChar = characterModels[9];
                const chatEl = document.getElementById('fat-chat');
                const notifEl = document.getElementById('fat-notif');
                if (chatEl && notifEl) {
                    // Position chat bubble above character head (3D to 2D projection)
                    const charPos = new THREE.Vector3();
                    fatChar.group.getWorldPosition(charPos);
                    const headPos = charPos.clone();
                    headPos.y += 3; // Above head

                    // Check distance from ghost
                    const distanceToGhost = ghostGroup.position.distanceTo(charPos);
                    const maxDistance = 50; // Maximum distance to show chat (only when close)

                    // Project to screen space
                    const screenPos = headPos.clone().project(camera);
                    const ghostScreenPos = ghostGroup.position.clone().project(camera);
                    const ghostHeadPos = ghostGroup.position.clone();
                    ghostHeadPos.y += 2; // Ghost head position
                    const ghostHeadScreenPos = ghostHeadPos.clone().project(camera);

                    // Check if on screen
                    const isOnScreen = screenPos.x >= -1 && screenPos.x <= 1 &&
                        screenPos.y >= -1 && screenPos.y <= 1 &&
                        screenPos.z < 1 && screenPos.z > -1;

                    // Calculate screen positions in pixels
                    const charScreenX = (screenPos.x * 0.5 + 0.5) * window.innerWidth;
                    const charScreenY = (-screenPos.y * 0.5 + 0.5) * window.innerHeight;
                    const ghostScreenX = (ghostScreenPos.x * 0.5 + 0.5) * window.innerWidth;
                    const ghostScreenY = (-ghostScreenPos.y * 0.5 + 0.5) * window.innerHeight;
                    const ghostHeadScreenX = (ghostHeadScreenPos.x * 0.5 + 0.5) * window.innerWidth;
                    const ghostHeadScreenY = (-ghostHeadScreenPos.y * 0.5 + 0.5) * window.innerHeight;

                    // Chat bubble position (above character head)
                    const chatX = charScreenX;
                    const chatY = charScreenY - 160; // Higher position for fat.glb

                    // F notification position (above chat bubble)
                    const notifY = chatY - 40; // Position F notification above chat

                    // Check if chat bubble overlaps with ghost
                    const chatWidth = 250; // max-width of chat
                    const chatHeight = 50; // approximate chat height
                    const chatLeft = chatX - chatWidth / 2;
                    const chatRight = chatX + chatWidth / 2;
                    const chatTop = chatY - chatHeight / 2;
                    const chatBottom = chatY + chatHeight / 2;

                    // Ghost bounding box (approximate)
                    const ghostSize = 80; // approximate ghost size in pixels
                    const ghostLeft = ghostHeadScreenX - ghostSize;
                    const ghostRight = ghostHeadScreenX + ghostSize;
                    const ghostTop = ghostHeadScreenY - ghostSize;
                    const ghostBottom = ghostHeadScreenY + ghostSize;

                    // Check if chat bubble overlaps with ghost
                    const isOverlapping = !(chatRight < ghostLeft || chatLeft > ghostRight ||
                        chatBottom < ghostTop || chatTop > ghostBottom);

                    // Check if ghost is between camera and character (would cause overlay)
                    const cameraToChar = new THREE.Vector3().subVectors(headPos, camera.position);
                    const cameraToGhost = new THREE.Vector3().subVectors(ghostGroup.position, camera.position);
                    const charDistance = cameraToChar.length();
                    const ghostDistance = cameraToGhost.length();

                    // Ghost is blocking if it's closer to camera AND overlapping on screen
                    const ghostIsBlocking = ghostDistance < charDistance && isOverlapping;

                    // Only show if:
                    // 1. Ghost is within distance range (close enough)
                    // 2. Character is on screen
                    // 3. Ghost is not blocking the character
                    if (isOnScreen &&
                        distanceToGhost <= maxDistance &&
                        !ghostIsBlocking) {

                        // Update message every 3 seconds (only when visible)
                        if (time - fatLastMessageChangeTime >= 3) {
                            fatCurrentMessageIndex = (fatCurrentMessageIndex + 1) % fatMessages.length;
                            chatEl.textContent = fatMessages[fatCurrentMessageIndex];
                            fatLastMessageChangeTime = time;
                        }

                        // Position chat bubble
                        chatEl.style.left = chatX + 'px';
                        chatEl.style.top = chatY + 'px';
                        chatEl.style.transform = 'translateX(-50%)';
                        chatEl.style.display = 'block';

                        // Position F notification above chat bubble
                        notifEl.style.left = chatX + 'px';
                        notifEl.style.top = notifY + 'px';
                        notifEl.style.transform = 'translateX(-50%)';
                        notifEl.style.display = 'block';
                    } else {
                        chatEl.style.display = 'none';
                        notifEl.style.display = 'none';
                    }
                }
            }

            // ── LM Character Chat (Auto-rotating messages) ──────────────────────────
            if (characterModels[8] && characterModels[8].group) {
                const lmChar = characterModels[8];
                const chatEl = document.getElementById('lm-chat');
                const notifEl = document.getElementById('lm-notif');
                if (chatEl && notifEl) {
                    // Position chat bubble above character head (3D to 2D projection)
                    const charPos = new THREE.Vector3();
                    lmChar.group.getWorldPosition(charPos);
                    const headPos = charPos.clone();
                    headPos.y += 3; // Above head

                    // Check distance from ghost
                    const distanceToGhost = ghostGroup.position.distanceTo(charPos);
                    const maxDistance = 50; // Maximum distance to show chat (only when close)

                    // Project to screen space
                    const screenPos = headPos.clone().project(camera);
                    const ghostScreenPos = ghostGroup.position.clone().project(camera);
                    const ghostHeadPos = ghostGroup.position.clone();
                    ghostHeadPos.y += 2; // Ghost head position
                    const ghostHeadScreenPos = ghostHeadPos.clone().project(camera);

                    // Check if on screen
                    const isOnScreen = screenPos.x >= -1 && screenPos.x <= 1 &&
                        screenPos.y >= -1 && screenPos.y <= 1 &&
                        screenPos.z < 1 && screenPos.z > -1;

                    // Calculate screen positions in pixels
                    const charScreenX = (screenPos.x * 0.5 + 0.5) * window.innerWidth;
                    const charScreenY = (-screenPos.y * 0.5 + 0.5) * window.innerHeight;
                    const ghostScreenX = (ghostScreenPos.x * 0.5 + 0.5) * window.innerWidth;
                    const ghostScreenY = (-ghostScreenPos.y * 0.5 + 0.5) * window.innerHeight;
                    const ghostHeadScreenX = (ghostHeadScreenPos.x * 0.5 + 0.5) * window.innerWidth;
                    const ghostHeadScreenY = (-ghostHeadScreenPos.y * 0.5 + 0.5) * window.innerHeight;

                    // Chat bubble position (above character head)
                    const chatX = charScreenX;
                    const chatY = charScreenY - 160; // Higher position for lm.glb

                    // F notification position (above chat bubble)
                    const notifY = chatY - 40; // Position F notification above chat

                    // Check if chat bubble overlaps with ghost
                    const chatWidth = 250; // max-width of chat
                    const chatHeight = 50; // approximate chat height
                    const chatLeft = chatX - chatWidth / 2;
                    const chatRight = chatX + chatWidth / 2;
                    const chatTop = chatY - chatHeight / 2;
                    const chatBottom = chatY + chatHeight / 2;

                    // Ghost bounding box (approximate)
                    const ghostSize = 80; // approximate ghost size in pixels
                    const ghostLeft = ghostHeadScreenX - ghostSize;
                    const ghostRight = ghostHeadScreenX + ghostSize;
                    const ghostTop = ghostHeadScreenY - ghostSize;
                    const ghostBottom = ghostHeadScreenY + ghostSize;

                    // Check if chat bubble overlaps with ghost
                    const isOverlapping = !(chatRight < ghostLeft || chatLeft > ghostRight ||
                        chatBottom < ghostTop || chatTop > ghostBottom);

                    // Check if ghost is between camera and character (would cause overlay)
                    const cameraToChar = new THREE.Vector3().subVectors(headPos, camera.position);
                    const cameraToGhost = new THREE.Vector3().subVectors(ghostGroup.position, camera.position);
                    const charDistance = cameraToChar.length();
                    const ghostDistance = cameraToGhost.length();

                    // Ghost is blocking if it's closer to camera AND overlapping on screen
                    const ghostIsBlocking = ghostDistance < charDistance && isOverlapping;

                    // Only show if:
                    // 1. Ghost is within distance range (close enough)
                    // 2. Character is on screen
                    // 3. Ghost is not blocking the character
                    if (isOnScreen &&
                        distanceToGhost <= maxDistance &&
                        !ghostIsBlocking) {

                        // Update message every 3 seconds (only when visible)
                        if (time - lmLastMessageChangeTime >= 3) {
                            lmCurrentMessageIndex = (lmCurrentMessageIndex + 1) % lmMessages.length;
                            chatEl.textContent = lmMessages[lmCurrentMessageIndex];
                            lmLastMessageChangeTime = time;
                        }

                        // Position chat bubble
                        chatEl.style.left = chatX + 'px';
                        chatEl.style.top = chatY + 'px';
                        chatEl.style.transform = 'translateX(-50%)';
                        chatEl.style.display = 'block';

                        // Position F notification above chat bubble
                        notifEl.style.left = chatX + 'px';
                        notifEl.style.top = notifY + 'px';
                        notifEl.style.transform = 'translateX(-50%)';
                        notifEl.style.display = 'block';
                    } else {
                        chatEl.style.display = 'none';
                        notifEl.style.display = 'none';
                    }
                }
            }

            renderer.render(scene, camera);
        }

        // ── Load GLTF Models with Different Colors ────────────────────────────────

        // Initialize Draco Loader for mesh compression
        const dracoLoader = new DRACOLoader();
        dracoLoader.setDecoderPath('https://www.gstatic.com/draco/versioned/decoders/1.5.7/');
        
        const gltfLoader = new GLTFLoader();
        gltfLoader.setDRACOLoader(dracoLoader);

        // Store character model references
        const characterModels = [];
        const characterTimeouts = []; // Store timeout IDs for each character

        // Helper function to create colored material
        function createColoredMaterial(color) {
            return new THREE.MeshStandardMaterial({
                color: color,
                roughness: 0.5,
                metalness: 0.3
            });
        }
        // Helper function to load model with custom colors
        function loadModelWithColor(colorHex, position, modelName, charIndex) {
            gltfLoader.load('/e.glb', (gltf) => {
                const modelGroup = new THREE.Group();
                modelGroup.position.set(position.x, position.y, position.z);
                modelGroup.rotation.y = -Math.PI / 2; // Face the screen (180 degrees)
                modelGroup.scale.set(12, 12, 12);

                const bodyMaterial = createColoredMaterial(colorHex);
                const eyeTeethMaterial = new THREE.MeshStandardMaterial({
                    color: 0xFFFFFF,
                    roughness: 0.3,
                    metalness: 0.1
                });

                // Get all meshes from the model
                gltf.scene.traverse((child) => {
                    if (child instanceof THREE.Mesh) {
                        const clonedMesh = child.clone();
                        const meshName = child.name.toLowerCase();

                        // Detect what part this is
                        if (meshName.includes('eye') || meshName.includes('pupil')) {
                            // Eyes get white
                            clonedMesh.material = eyeTeethMaterial;
                        } else if (meshName.includes('tooth') || meshName.includes('teeth')) {
                            // Teeth get white
                            clonedMesh.material = eyeTeethMaterial;
                        } else if (meshName.includes('body') || meshName.includes('head') ||
                            meshName.includes('skin') || meshName.includes('character') ||
                            child.material && child.material.color) {
                            // Only apply color to body-like materials
                            if (child.material && !(meshName.includes('eye') || meshName.includes('tooth'))) {
                                // Clone the original material and change its color
                                const newMat = child.material.clone();
                                newMat.color.setHex(colorHex);
                                clonedMesh.material = newMat;
                            }
                        }

                        clonedMesh.castShadow = true;
                        clonedMesh.receiveShadow = true;
                        modelGroup.add(clonedMesh);
                    }
                });

                scene.add(modelGroup);
                // Store reference to character model
                characterModels[charIndex] = {
                    group: modelGroup,
                    position: position,
                    isInteracting: false
                };
            });
        }


        // Model 1: Pink Character
        function loadGreenModel() {
            loadModelWithColor(0xDDAED3, { x: -20, y: 7, z: -150 }, 'Yellow', 0);
        }

        // Model 2:  Pink Character
        function loadYellowModel() {
            loadModelWithColor(0xDDAED3, { x: 0, y: 7, z: -150 }, 'Yellow', 1);
        }

        // Model 3: Pink Character (Default)
        function loadPinkModel() {
            loadModelWithColor(0xDDAED3, { x: 20, y: 7, z: -150 }, 'Yellow', 2);
        }

        // Model 4: New Character (f.glb)
        function loadFModel() {
            gltfLoader.load('/f.glb', (gltf) => {
                const modelGroup = new THREE.Group();
                modelGroup.position.set(-130, 7, -40); // Position like pink characters
                modelGroup.rotation.y = -Math.PI / 2; // Face the screen (same as pink characters)
                modelGroup.scale.set(12, 12, 12); // Same scale as pink characters

                // Get all meshes from the model and clone them
                gltf.scene.traverse((child) => {
                    if (child instanceof THREE.Mesh) {
                        const clonedMesh = child.clone();
                        clonedMesh.castShadow = true;
                        clonedMesh.receiveShadow = true;
                        modelGroup.add(clonedMesh);
                    }
                });

                scene.add(modelGroup);
                // Store reference to character model (index 3)
                characterModels[3] = {
                    group: modelGroup,
                    position: { x: -90, y: 7, z: -40 },
                    isInteracting: false
                };
            }, undefined, (error) => {
                console.error('Error loading f.glb:', error);
            });
        }


        // Model 6: Angle Character (angle.glb)
        function loadAngleModel() {
            gltfLoader.load('/angle.glb', (gltf) => {
                const modelGroup = new THREE.Group();
                modelGroup.position.set(-67, 7, 10); // Position next to f.glb (on the left side)
                modelGroup.rotation.y = Math.PI; // Same rotation as f.glb
                modelGroup.scale.set(12, 12, 12); // Same scale as f.glb

                // Get all meshes from the model and clone them
                gltf.scene.traverse((child) => {
                    if (child instanceof THREE.Mesh) {
                        const clonedMesh = child.clone();
                        clonedMesh.castShadow = true;
                        clonedMesh.receiveShadow = true;
                        modelGroup.add(clonedMesh);
                    }
                });

                scene.add(modelGroup);
                // Store reference to character model (index 5)
                characterModels[5] = {
                    group: modelGroup,
                    position: { x: -67, y: 7, z: 10 },
                    isInteracting: false
                };
            }, undefined, (error) => {
                console.error('Error loading angle.glb:', error);
            });
        }

        // Model: Lotus Character (lotusns.glb)
        function loadLotusModel() {
            gltfLoader.load('/lotusns.glb', (gltf) => {
                const modelGroup = new THREE.Group();
                modelGroup.position.set(-60, 7, 50); // Position next to angle.glb (which is at -67, 7, 10)
                modelGroup.rotation.y = Math.PI; // Same rotation as angle.glb
                modelGroup.scale.set(35, 35, 35); // Same scale as angle.glb

                // Get all meshes from the model and clone them
                gltf.scene.traverse((child) => {
                    if (child instanceof THREE.Mesh) {
                        const clonedMesh = child.clone();
                        clonedMesh.castShadow = true;
                        clonedMesh.receiveShadow = true;
                        modelGroup.add(clonedMesh);
                    }
                });

                scene.add(modelGroup);
                // Store reference to character model (index 10)
                characterModels[10] = {
                    group: modelGroup,
                    position: { x: -60, y: 7, z: 10 },
                    isInteracting: false
                };
            }, undefined, (error) => {
                console.error('Error loading lotusns.glb:', error);
            });
        }

        // Model: Lotus Character (lotusns.glb) - Second instance
        function loadLotusModel2() {
            gltfLoader.load('/lotusns.glb', (gltf) => {
                const modelGroup = new THREE.Group();
                modelGroup.position.set(-60, 7, -35); // Position next to first lotus model (different z position)
                modelGroup.rotation.y = Math.PI; // Same rotation as other models
                modelGroup.scale.set(40, 40, 40); // Same scale as other models

                // Get all meshes from the model and clone them
                gltf.scene.traverse((child) => {
                    if (child instanceof THREE.Mesh) {
                        const clonedMesh = child.clone();
                        clonedMesh.castShadow = true;
                        clonedMesh.receiveShadow = true;
                        modelGroup.add(clonedMesh);
                    }
                });

                scene.add(modelGroup);
                // Store reference to character model (index 15)
                characterModels[15] = {
                    group: modelGroup,
                    position: { x: -60, y: 7, z: 20 },
                    isInteracting: false
                };
            }, undefined, (error) => {
                console.error('Error loading lotusns.glb (second instance):', error);
            });
        }

        // Model: Daisy Character (daisy.glb)
        function loadDaisyModel() {
            gltfLoader.load('/daisy.glb', (gltf) => {
                const modelGroup = new THREE.Group();
                modelGroup.position.set(-270, 7, 10); // Position next to lotus model (which is at -60, 7, 10)
                modelGroup.rotation.y = Math.PI / 20; // Same rotation as lotus model
                modelGroup.scale.set(40, 40, 40); // Same scale as lotus model

                // Get all meshes from the model and clone them
                gltf.scene.traverse((child) => {
                    if (child instanceof THREE.Mesh) {
                        const clonedMesh = child.clone();
                        clonedMesh.castShadow = true;
                        clonedMesh.receiveShadow = true;
                        modelGroup.add(clonedMesh);
                    }
                });

                scene.add(modelGroup);
                // Store reference to character model (index 11)
                characterModels[11] = {
                    group: modelGroup,
                    position: { x: -53, y: 7, z: 10 },
                    isInteracting: false
                };
            }, undefined, (error) => {
                console.error('Error loading daisy.glb:', error);
            });
        }

        // Model: Lotus Character (lotus.glb)
        function loadLotus2Model() {
            gltfLoader.load('/lotus.glb', (gltf) => {
                const modelGroup = new THREE.Group();
                modelGroup.position.set(-55, 7, 10); // Position next to daisy model (which is at -53, 7, 10)
                modelGroup.rotation.y = Math.PI+  0.4; // Same rotation as other models
                modelGroup.scale.set(45, 45, 45); // Same scale as other models

                // Get all meshes from the model and clone them
                gltf.scene.traverse((child) => {
                    if (child instanceof THREE.Mesh) {
                        const clonedMesh = child.clone();
                        clonedMesh.castShadow = true;
                        clonedMesh.receiveShadow = true;
                        modelGroup.add(clonedMesh);
                    }
                });

                scene.add(modelGroup);
                // Store reference to character model (index 12)
                characterModels[12] = {
                    group: modelGroup,
                    position: { x: -46, y: 7, z: 10 },
                    isInteracting: false
                };
            }, undefined, (error) => {
                console.error('Error loading lotus.glb:', error);
            });
        }

        // Model: Threlef Character (threlef.glb)
        function loadThrelefModel() {
            gltfLoader.load('/threlef.glb', (gltf) => {
                const modelGroup = new THREE.Group();
                modelGroup.position.set(-115, 7, 150); // Position next to lotus2 model (which is at -46, 7, 10)
                modelGroup.rotation.y = Math.PI + 5; // Same rotation as other models
                modelGroup.scale.set(30, 30, 30); // Same scale as other models

                // Get all meshes from the model and clone them
                gltf.scene.traverse((child) => {
                    if (child instanceof THREE.Mesh) {
                        const clonedMesh = child.clone();
                        clonedMesh.castShadow = true;
                        clonedMesh.receiveShadow = true;
                        modelGroup.add(clonedMesh);
                    }
                });

                scene.add(modelGroup);
                // Store reference to character model (index 13)
                characterModels[13] = {
                    group: modelGroup,
                    position: { x: -39, y: 7, z: 10 },
                    isInteracting: false
                };
            }, undefined, (error) => {
                console.error('Error loading threlef.glb:', error);
            });
        }
        function loadThrelefModel2() {
            gltfLoader.load('/threlef.glb', (gltf) => {
                const modelGroup = new THREE.Group();
                modelGroup.position.set(-200, 7, 120); // Position next to lotus2 model (which is at -46, 7, 10)
                modelGroup.rotation.y = Math.PI + 39; // Same rotation as other models
                modelGroup.scale.set(30, 30, 30); // Same scale as other models

                // Get all meshes from the model and clone them
                gltf.scene.traverse((child) => {
                    if (child instanceof THREE.Mesh) {
                        const clonedMesh = child.clone();
                        clonedMesh.castShadow = true;
                        clonedMesh.receiveShadow = true;
                        modelGroup.add(clonedMesh);
                    }
                });

                scene.add(modelGroup);
                // Store reference to character model (index 13)
                characterModels[13] = {
                    group: modelGroup,
                    position: { x: -39, y: 7, z: 10 },
                    isInteracting: false
                };
            }, undefined, (error) => {
                console.error('Error loading threlef.glb:', error);
            });
        }

        // Model: Pinkf Character (pinkf.glb)
        function loadPinkfModel() {
            gltfLoader.load('/pinkf.glb', (gltf) => {
                const modelGroup = new THREE.Group();
                modelGroup.position.set(-232, 7, 70); // Position next to threlef model (which is at -39, 7, 10)
                modelGroup.rotation.y = Math.PI + 10; // Same rotation as other models
                modelGroup.scale.set(32, 32, 32); // Same scale as other models

                // Get all meshes from the model and clone them
                gltf.scene.traverse((child) => {
                    if (child instanceof THREE.Mesh) {
                        const clonedMesh = child.clone();
                        clonedMesh.castShadow = true;
                        clonedMesh.receiveShadow = true;
                        modelGroup.add(clonedMesh);
                    }
                });

                scene.add(modelGroup);
                // Store reference to character model (index 14)
                characterModels[14] = {
                    group: modelGroup,
                    position: { x: -32, y: 7, z: 10 },
                    isInteracting: false
                };
            }, undefined, (error) => {
                console.error('Error loading pinkf.glb:', error);
            });
        }
        function loadPinkfModel2() {
            gltfLoader.load('/pinkf.glb', (gltf) => {
                const modelGroup = new THREE.Group();
                modelGroup.position.set(-170, 7, -30); // Position next to threlef model (which is at -39, 7, 10)
                modelGroup.rotation.y = Math.PI + 15; // Same rotation as other models
                modelGroup.scale.set(32, 32, 32); // Same scale as other models

                // Get all meshes from the model and clone them
                gltf.scene.traverse((child) => {
                    if (child instanceof THREE.Mesh) {
                        const clonedMesh = child.clone();
                        clonedMesh.castShadow = true;
                        clonedMesh.receiveShadow = true;
                        modelGroup.add(clonedMesh);
                    }
                });

                scene.add(modelGroup);
                // Store reference to character model (index 14)
                characterModels[14] = {
                    group: modelGroup,
                    position: { x: -32, y: 7, z: 10 },
                    isInteracting: false
                };
            }, undefined, (error) => {
                console.error('Error loading pinkf.glb:', error);
            });
        }

        // Model 7: VE Character (ve.glb)
        function loadVEModel() {
            gltfLoader.load('/ve.glb', (gltf) => {
                const modelGroup = new THREE.Group();
                modelGroup.position.set(-140, 7, -40); // Position next to angle.glb (which is at -10, 7, 0)
                modelGroup.rotation.y = -Math.PI / 2; // Same rotation as other characters
                modelGroup.scale.set(12, 12, 12); // Same scale as other characters

                // Get all meshes from the model and clone them
                gltf.scene.traverse((child) => {
                    if (child instanceof THREE.Mesh) {
                        const clonedMesh = child.clone();
                        clonedMesh.castShadow = true;
                        clonedMesh.receiveShadow = true;
                        modelGroup.add(clonedMesh);
                    }
                });

                scene.add(modelGroup);
                // Store reference to character model (index 6)
                characterModels[6] = {
                    group: modelGroup,
                    position: { x: -100, y: 7, z: -40 },
                    isInteracting: false
                };
            }, undefined, (error) => {
                console.error('Error loading ve.glb:', error);
            });
        }

        // Model 8: PP Character (pp.glb)
        function loadPPModel() {
            gltfLoader.load('/pp.glb', (gltf) => {
                const modelGroup = new THREE.Group();
                modelGroup.position.set(-150, 7, -40); // Position next to ve.glb (which is at -100, 7, -40)
                modelGroup.rotation.y = -Math.PI / 2; // Same rotation as ve.glb
                modelGroup.scale.set(12, 12, 12); // Same scale as other characters

                // Get all meshes from the model and clone them
                gltf.scene.traverse((child) => {
                    if (child instanceof THREE.Mesh) {
                        const clonedMesh = child.clone();
                        clonedMesh.castShadow = true;
                        clonedMesh.receiveShadow = true;
                        modelGroup.add(clonedMesh);
                    }
                });

                scene.add(modelGroup);
                // Store reference to character model (index 7)
                characterModels[7] = {
                    group: modelGroup,
                    position: { x: -110, y: 7, z: -40 },
                    isInteracting: false
                };
            }, undefined, (error) => {
                console.error('Error loading pp.glb:', error);
            });
        }

        // Model 9: LM Character (lm.glb)
        function loadLMModel() {
            gltfLoader.load('/lm.glb', (gltf) => {
                const modelGroup = new THREE.Group();
                modelGroup.position.set(-160, 4, -10); // Position next to ve.glb (which is at -100, 7, -40)
                modelGroup.rotation.y = Math.PI / 4; // Same rotation as ve.glb
                modelGroup.scale.set(6, 6, 6); // Same scale as other characters

                // Get all meshes from the model and clone them
                gltf.scene.traverse((child) => {
                    if (child instanceof THREE.Mesh) {
                        const clonedMesh = child.clone();
                        clonedMesh.castShadow = true;
                        clonedMesh.receiveShadow = true;
                        modelGroup.add(clonedMesh);
                    }
                });

                scene.add(modelGroup);
                // Store reference to character model (index 8)
                characterModels[8] = {
                    group: modelGroup,
                    position: { x: -120, y: 4, z: -10 },
                    isInteracting: false
                };

                // Initialize first chat message
                const chatEl = document.getElementById('lm-chat');
                if (chatEl) {
                    chatEl.textContent = lmMessages[0];
                }
            }, undefined, (error) => {
                console.error('Error loading lm.glb:', error);
            });
        }

        // Model 10: FAT Character (fat.glb)
        function loadFATModel() {
            gltfLoader.load('/fat.glb', (gltf) => {
                const modelGroup = new THREE.Group();
                modelGroup.position.set(-140, 7, -13); // Position next to lm.glb (which is at -120, 4, -10)
                modelGroup.rotation.y = Math.PI / 4; // Same rotation as lm.glb
                modelGroup.scale.set(18, 18, 18); // Same scale as lm.glb

                // Get all meshes from the model and clone them
                gltf.scene.traverse((child) => {
                    if (child instanceof THREE.Mesh) {
                        const clonedMesh = child.clone();
                        clonedMesh.castShadow = true;
                        clonedMesh.receiveShadow = true;
                        modelGroup.add(clonedMesh);
                    }
                });

                scene.add(modelGroup);
                // Store reference to character model (index 9)
                characterModels[9] = {
                    group: modelGroup,
                    position: { x: -100, y: 7, z: -13 },
                    isInteracting: false
                };

                // Initialize first chat message
                const chatEl = document.getElementById('fat-chat');
                if (chatEl) {
                    chatEl.textContent = fatMessages[0];
                }
            }, undefined, (error) => {
                console.error('Error loading fat.glb:', error);
            });
        }

        // Load all models
        loadGreenModel();
        loadYellowModel();
        loadPinkModel();
        loadFModel();
        loadAngleModel();
        loadLotusModel();
        loadLotusModel2();
        loadDaisyModel();
        loadLotus2Model();
        loadThrelefModel2()
        loadThrelefModel();
        loadPinkfModel();
        loadPinkfModel2();
        loadVEModel();
        loadPPModel();
        loadLMModel();
        loadFATModel();

        // ── Load New Character Model (ld.glb) ────────────────────────────────────────
        let newCharacterGroup = null;
        const newCharMessages = [
            "You should Do my prompt better .........",
            "You should ... Fix line 52 to margin 0 for me -.-''",
            "You should Clean .. blah #lah bl#h ...",
            "Or i will find another better model ...."
        ];
        let currentMessageIndex = 0;
        let lastMessageChangeTime = 0;

        function loadNewCharacter() {
            gltfLoader.load('/ld.glb', (gltf) => {
                const modelGroup = new THREE.Group();
                // Position opposite to pink characters (they're at z: -30, this at z: 30)
                modelGroup.position.set(0, 3, -130);
                // Rotate to face away from screen (back facing screen)
                modelGroup.rotation.y = Math.PI / 2; // Face positive z direction (away from screen)
                modelGroup.scale.set(7, 7, 7);

                // Get all meshes from the model and clone them
                gltf.scene.traverse((child) => {
                    if (child instanceof THREE.Mesh) {
                        const clonedMesh = child.clone();
                        clonedMesh.castShadow = true;
                        clonedMesh.receiveShadow = true;
                        modelGroup.add(clonedMesh);
                    }
                });

                scene.add(modelGroup);
                newCharacterGroup = modelGroup;

                // Show chat bubble immediately
                const chatEl = document.getElementById('newchar-chat');
                if (chatEl) {
                    chatEl.style.display = 'block';
                    chatEl.textContent = newCharMessages[0];
                }
            }, undefined, (error) => {
                console.error('Error loading ld.glb:', error);
            });
        }

        // Load the new character
        loadNewCharacter();

        // Debounce resize handler for better INP
        let resizeTimeout = null;
        window.addEventListener('resize', () => {
            if (resizeTimeout) clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                camera.aspect = innerWidth / innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(innerWidth, innerHeight);
            }, 100);
        }, { passive: true });
        animate();
    </script>
</body>

</html>